<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Deal Cashflow Model (Single-File + Charts + Sliders)</title>

    <!-- React + ReactDOM (UMD) -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>

    <!-- Babel (so you can run JSX in a single HTML file) -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <!-- Chart.js (UMD) -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>

    <style>
      :root {
        --border: #ddd;
        --border2: #eee;
        --text: #111;
        --muted: #555;
        --bg: #fff;
      }
      body {
        margin: 0;
        background: #fafafa;
        color: var(--text);
        font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      }
      .page {
        padding: 18px;
        max-width: 1400px;
        margin: 0 auto;
      }
      .row {
        display: flex;
        gap: 12px;
        flex-wrap: wrap;
        align-items: center;
      }
      h1 {
        margin: 0;
        font-size: 18px;
      }
      .small {
        color: var(--muted);
        font-size: 12px;
      }
      .controls {
        margin-left: auto;
        display: flex;
        gap: 10px;
        flex-wrap: wrap;
        align-items: center;
      }
      label {
        display: inline-flex;
        flex-direction: column;
        gap: 4px;
      }
      input[type="number"],
      input[type="month"],
      input[type="checkbox"] {
        padding: 4px 6px;
        border: 1px solid var(--border);
        border-radius: 8px;
        background: var(--bg);
      }
      input[type="checkbox"] {
        width: 16px;
        height: 16px;
        padding: 0;
        border-radius: 4px;
      }
      input[type="range"] {
        width: 220px;
      }

      .cardRow {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
        gap: 12px;
        margin-top: 14px;
      }
      .card {
        border: 1px solid var(--border);
        border-radius: 12px;
        padding: 12px;
        background: var(--bg);
      }
      .card .value {
        font-size: 20px;
        margin-top: 6px;
      }

      .badgeRow {
        display: flex;
        gap: 8px;
        flex-wrap: wrap;
        align-items: center;
      }
      .badge {
        display: inline-block;
        padding: 2px 8px;
        border-radius: 999px;
        border: 1px solid var(--border);
        font-size: 12px;
        color: #333;
        background: var(--bg);
      }

      .section {
        margin-top: 18px;
      }
      .sectionTitle {
        font-weight: 600;
        margin-bottom: 8px;
      }
      .tableWrap {
        overflow-x: auto;
        border: 1px solid var(--border);
        border-radius: 12px;
        background: var(--bg);
      }
      table {
        width: 100%;
        border-collapse: collapse;
      }
      th {
        text-align: left;
        border-bottom: 1px solid var(--border);
        padding: 8px 6px;
        font-size: 12px;
        color: #444;
        background: #fcfcfc;
        white-space: nowrap;
      }
      td {
        border-bottom: 1px solid var(--border2);
        padding: 8px 6px;
        vertical-align: top;
        font-size: 13px;
      }
      tr:last-child td {
        border-bottom: none;
      }
      details summary {
        cursor: pointer;
      }
      .right {
        text-align: right;
      }
      .mono {
        font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono",
          "Courier New", monospace;
      }

      /* Charts */
      .chartGrid {
        display: grid;
        grid-template-columns: 1fr;
        gap: 12px;
        margin-top: 12px;
      }
      @media (min-width: 1100px) {
        .chartGrid {
          grid-template-columns: 1fr 1fr;
        }
      }
      .chartCard {
        border: 1px solid var(--border);
        border-radius: 12px;
        padding: 12px;
        background: var(--bg);
      }
      .chartHeader {
        display: flex;
        align-items: flex-end;
        justify-content: space-between;
        gap: 12px;
        flex-wrap: wrap;
        margin-bottom: 8px;
      }
      .chartTitle {
        font-weight: 600;
      }
      .chartTools {
        display: flex;
        gap: 10px;
        align-items: center;
        flex-wrap: wrap;
      }
      .chartCanvasWrap {
        position: relative;
        height: 340px;
      }
      @media (min-width: 1100px) {
        .chartCanvasWrap {
          height: 360px;
        }
      }
      .hint {
        color: var(--muted);
        font-size: 12px;
        margin-top: 8px;
        line-height: 1.35;
      }
      .toggleRow {
        display: inline-flex;
        gap: 8px;
        align-items: center;
        user-select: none;
      }

      /* Slider UI */
      .sliderWrap {
        display: flex;
        flex-direction: column;
        gap: 6px;
        min-width: 280px;
      }
      .sliderRow {
        display: flex;
        gap: 10px;
        align-items: center;
        flex-wrap: wrap;
      }
      .mini {
        font-size: 11px;
        color: var(--muted);
      }
      .pill {
        display: inline-block;
        padding: 2px 8px;
        border-radius: 999px;
        border: 1px solid var(--border);
        background: #fff;
        font-size: 12px;
      }
      .sliderValue {
        font-weight: 600;
      }
      .tight {
        line-height: 1.25;
      }
    </style>
  </head>

  <body>
    <div id="root"></div>

    <script type="text/babel">
      const { useMemo, useState, useEffect, useRef } = React;

      /***************
       * Utilities
       ***************/
      const GBP = 1_000_000;

      function pad2(n) {
        return String(n).padStart(2, "0");
      }

      function gbp(n) {
        const sign = n < 0 ? "-" : "";
        const abs = Math.abs(n);
        return sign + "£" + abs.toLocaleString(undefined, { maximumFractionDigits: 0 });
      }

      function pct(n) {
        return (n * 100).toFixed(1) + "%";
      }

      // MonthStr is "YYYY-MM"
      function monthToYMD(month) {
        const [yStr, mStr] = month.split("-");
        return { y: Number(yStr), m: Number(mStr) }; // m: 1-12
      }

      function fmtMonth(y, m) {
        return `${y}-${pad2(m)}`;
      }

      function addMonths(month, delta) {
        const { y, m } = monthToYMD(month);
        let total = y * 12 + (m - 1) + delta;
        const ny = Math.floor(total / 12);
        const nm0 = total % 12;
        const nm = nm0 + 1;
        return fmtMonth(ny, nm);
      }

      function dateUTC(y, m, d) {
        return new Date(Date.UTC(y, m - 1, d));
      }

      function monthDate15(month) {
        const { y, m } = monthToYMD(month);
        return dateUTC(y, m, 15);
      }

      function addDaysUTC(d, days) {
        const nd = new Date(d.getTime());
        nd.setUTCDate(nd.getUTCDate() + days);
        return nd;
      }

      function toISODate(d) {
        const y = d.getUTCFullYear();
        const m = pad2(d.getUTCMonth() + 1);
        const day = pad2(d.getUTCDate());
        return `${y}-${m}-${day}`;
      }

      function isMonthEndUTC(d) {
        const next = addDaysUTC(d, 1);
        return next.getUTCMonth() !== d.getUTCMonth();
      }

      function endOfMonthUTC(month) {
        const { y, m } = monthToYMD(month);
        const firstNext = m === 12 ? dateUTC(y + 1, 1, 1) : dateUTC(y, m + 1, 1);
        return addDaysUTC(firstNext, -1);
      }

      // Slider mapping: March..September 2026
      const SALE_MONTHS = ["2026-03","2026-04","2026-05","2026-06","2026-07","2026-08","2026-09"];

      function saleIndexFromMonth(month) {
        const idx = SALE_MONTHS.indexOf(month);
        return idx >= 0 ? idx : 0;
      }
      function saleMonthFromIndex(i) {
        const idx = Math.min(Math.max(Number(i), 0), SALE_MONTHS.length - 1);
        return SALE_MONTHS[idx];
      }

      /***************
       * Model logic
       ***************/
      function typePriority(t) {
        // 1) Customer receipts 2) Manufacturer deposits 3) Rebates 4) Sweep/draw 5) Month-end interest
        switch (t) {
          case "CUST_IN":
            return 1;
          case "MFG_OUT":
            return 2;
          case "REBATE_IN":
            return 3;
          case "DEBT_REPAY":
            return 4;
          case "DEBT_DRAW":
            return 4;
          case "INT_PAID":
            return 5;
          default:
            return 99;
        }
      }

      function computeDueMonths(deal, prodStartMonth) {
        // Customer due lead is fixed at 1 month ahead
        const d2DepositMonth = "2026-07"; // manufacturer D2 month
        const dueD2 = addMonths(d2DepositMonth, -1); // June 2026
        const dueD3 = addMonths(prodStartMonth, -1);
        const deliveryMonth = addMonths(prodStartMonth, deal.buildMonths);
        const dueD4 = addMonths(deliveryMonth, -1);
        return { dueD2, dueD3, dueD4, deliveryMonth };
      }

      function paidFromDueAndLate(dueMonth, lateMonths) {
        return addMonths(dueMonth, lateMonths);
      }

      function buildCashflow(deal, cars) {
        const numCars = cars.length;

        // per car deposits
        const D1 = 1 * GBP;
        const D2 = 1 * GBP;
        const D3 = 1 * GBP;
        const D4 = 2 * GBP;

        // rebates: 10% of each deposit; P4 = 10% of D4 (0.2m)
        const R1 = 0.1 * GBP;
        const R2 = 0.1 * GBP;
        const R3 = 0.1 * GBP;
        const R4 = 0.2 * GBP;

        const raw = [];

        // Fixed manufacturer deposits (portfolio-level)
        raw.push({
          date: dateUTC(2026, 2, 1),
          type: "MFG_OUT",
          label: "Manufacturer D1 (all cars)",
          amount: -(D1 * numCars),
        });
        raw.push({
          date: dateUTC(2026, 7, 15),
          type: "MFG_OUT",
          label: "Manufacturer D2 (all cars)",
          amount: -(D2 * numCars),
        });

        // Fixed rebates (portfolio-level)
        raw.push({
          date: dateUTC(2026, 5, 15),
          type: "REBATE_IN",
          label: "Rebate P1 = 10% of D1 (all cars)",
          amount: +(R1 * numCars),
        });
        raw.push({
          date: dateUTC(2026, 8, 1),
          type: "REBATE_IN",
          label: "Rebate P2 = 10% of D2 (all cars)",
          amount: +(R2 * numCars),
        });

        // Per-car events
        for (const c of cars) {
          // Customer D1 on sale date (15th)
          raw.push({
            date: monthDate15(c.saleMonth),
            type: "CUST_IN",
            tranche: "D1",
            label: `Car ${c.id}: Customer D1 receipt`,
            amount: +D1,
          });

          const { dueD2, dueD3, dueD4 } = computeDueMonths(deal, c.prodStartMonth);

          // Paid months are due month + lateMonths (lateMonths applies to D2/D3/D4)
          const paidD2Month = paidFromDueAndLate(dueD2, c.lateMonths);
          const paidD3Month = paidFromDueAndLate(dueD3, c.lateMonths);
          const paidD4Month = paidFromDueAndLate(dueD4, c.lateMonths);

          raw.push({
            date: monthDate15(paidD2Month),
            type: "CUST_IN",
            tranche: "D2",
            label: `Car ${c.id}: Customer D2 receipt (late ${c.lateMonths}m)`,
            amount: +D2,
          });
          raw.push({
            date: monthDate15(paidD3Month),
            type: "CUST_IN",
            tranche: "D3",
            label: `Car ${c.id}: Customer D3 receipt (late ${c.lateMonths}m)`,
            amount: +D3,
          });
          raw.push({
            date: monthDate15(paidD4Month),
            type: "CUST_IN",
            tranche: "D4",
            label: `Car ${c.id}: Customer D4 receipt (late ${c.lateMonths}m)`,
            amount: +D4,
          });

          const prodStart = monthDate15(c.prodStartMonth);
          const deliveryMonth = addMonths(c.prodStartMonth, deal.buildMonths);
          const deliveryDate = monthDate15(deliveryMonth);

          // Manufacturer D3 / D4
          raw.push({
            date: prodStart,
            type: "MFG_OUT",
            label: `Car ${c.id}: Manufacturer D3`,
            amount: -D3,
          });
          raw.push({
            date: deliveryDate,
            type: "MFG_OUT",
            label: `Car ${c.id}: Manufacturer D4 (delivery)`,
            amount: -D4,
          });

          // Rebates P3/P4 = +14 days
          raw.push({
            date: addDaysUTC(prodStart, 14),
            type: "REBATE_IN",
            label: `Car ${c.id}: Rebate P3 = 10% of D3`,
            amount: +R3,
          });
          raw.push({
            date: addDaysUTC(deliveryDate, 14),
            type: "REBATE_IN",
            label: `Car ${c.id}: Rebate P4 = 10% of D4`,
            amount: +R4,
          });
        }

        // Determine sim window: start at deal.startMonth (1st day), end at max event month + 2
        const { y: sy, m: sm } = monthToYMD(deal.startMonth);
        const minDate = dateUTC(sy, sm, 1);

        let maxEventDate = minDate;
        for (const e of raw) {
          if (e.date > maxEventDate) maxEventDate = e.date;
        }
        const maxMonth = fmtMonth(maxEventDate.getUTCFullYear(), maxEventDate.getUTCMonth() + 1);
        const simEndMonth = addMonths(maxMonth, 2);
        const simEndDate = endOfMonthUTC(simEndMonth);

        // Group events by date
        const byDate = new Map();
        for (const e of raw) {
          const key = toISODate(e.date);
          if (!byDate.has(key)) byDate.set(key, []);
          byDate.get(key).push(e);
        }
        for (const [k, arr] of byDate.entries()) {
          arr.sort((a, b) => typePriority(a.type) - typePriority(b.type));
          byDate.set(k, arr);
        }

        // State
        let cash = 0;
        let debt = 0;
        let accruedInterestThisMonth = 0;

        let cumCustomerIn = 0;
        let cumCustD1 = 0;
        let cumCustD2 = 0;
        let cumCustD3 = 0;
        let cumCustD4 = 0;

        let cumMfgOut = 0;
        let cumRebatesIn = 0;
        let cumInterestPaid = 0;

        const ledger = [];
        const monthly = [];

        function record(dateISO, type, label, amount) {
          ledger.push({
            dateISO,
            type,
            label,
            amount,
            cashAfter: cash,
            debtAfter: debt,
          });
        }

        function drawIfNeeded(dateISO, context) {
          if (cash < 0) {
            const draw = -cash;
            debt += draw;
            cash = 0;
            record(dateISO, "DEBT_DRAW", `Debt draw (to fund ${context})`, +draw);
          }
        }

        function sweep(dateISO) {
          if (cash > 0 && debt > 0) {
            const repay = Math.min(cash, debt);
            cash -= repay;
            debt -= repay;
            record(dateISO, "DEBT_REPAY", "Debt repay (cash sweep)", -repay);
          }
        }

        // Iterate day-by-day UTC
        let d = new Date(minDate.getTime());
        while (d <= simEndDate) {
          const dateISO = toISODate(d);
          const todays = byDate.get(dateISO) || [];

          for (const e of todays) {
            cash += e.amount;

            if (e.type === "CUST_IN") {
              cumCustomerIn += e.amount;
              if (e.tranche === "D1") cumCustD1 += e.amount;
              if (e.tranche === "D2") cumCustD2 += e.amount;
              if (e.tranche === "D3") cumCustD3 += e.amount;
              if (e.tranche === "D4") cumCustD4 += e.amount;
            }
            if (e.type === "MFG_OUT") cumMfgOut += -e.amount; // store positive outflow
            if (e.type === "REBATE_IN") cumRebatesIn += e.amount;

            record(dateISO, e.type, e.label, e.amount);
            drawIfNeeded(dateISO, e.label);
          }

          // sweep same day
          sweep(dateISO);

          // daily interest accrual on end-of-day debt (ACT/365F)
          const dailyRate = deal.annualRate / 365.0;
          accruedInterestThisMonth += debt * dailyRate;

          // pay interest at month-end
          if (isMonthEndUTC(d)) {
            if (accruedInterestThisMonth > 0) {
              const pay = accruedInterestThisMonth;
              cash -= pay;
              cumInterestPaid += pay;
              record(dateISO, "INT_PAID", "Interest paid (month-end, ACT/365F)", -pay);
              accruedInterestThisMonth = 0;
              drawIfNeeded(dateISO, "interest payment");
            }

            const monthStr = fmtMonth(d.getUTCFullYear(), d.getUTCMonth() + 1);
            const netExposureUnfinanced = cumMfgOut - (cumCustomerIn + cumRebatesIn);

            monthly.push({
              month: monthStr,
              cashEOM: cash,
              debtEOM: debt,
              cumCustomerIn,
              cumCustD1,
              cumCustD2,
              cumCustD3,
              cumCustD4,
              cumMfgOut,
              cumRebatesIn,
              cumInterestPaid,
              netExposureUnfinanced,
            });
          }

          d = addDaysUTC(d, 1);
        }

        // KPIs
        let peakNet = { value: 0, month: monthly[0]?.month || deal.startMonth };
        let peakDebt = { value: 0, month: monthly[0]?.month || deal.startMonth };

        for (const r of monthly) {
          if (r.netExposureUnfinanced > peakNet.value) peakNet = { value: r.netExposureUnfinanced, month: r.month };
          if (r.debtEOM > peakDebt.value) peakDebt = { value: r.debtEOM, month: r.month };
        }

        const last = monthly[monthly.length - 1] || null;
        const totalRebates = last ? last.cumRebatesIn : 0;
        const totalInterestPaid = last ? last.cumInterestPaid : 0;

        let sawDebt = false;
        let debtClearedMonth = null;
        for (const r of monthly) {
          if (r.debtEOM > 0) sawDebt = true;
          if (sawDebt && r.debtEOM === 0) {
            debtClearedMonth = r.month;
            break;
          }
        }

        const profitAfterInterest = totalRebates - totalInterestPaid; // informational
        const interestAsPctOfRebates = totalRebates > 0 ? totalInterestPaid / totalRebates : 0;
        const profitOverPeakExposure = peakNet.value > 0 ? totalRebates / peakNet.value : 0;

        const kpis = {
          peakNetExposure: peakNet,
          peakDebt: peakDebt,
          totalRebates,
          totalInterestPaid,
          profitAfterInterest,
          interestAsPctOfRebates,
          profitOverPeakExposure,
          debtClearedMonth,
        };

        return { ledger, monthly, kpis };
      }

      /***************
       * Chart helpers
       ***************/
      function toMM(m) {
        return m; // keep YYYY-MM for auditability
      }

      function ChartCanvas({ config, ariaLabel }) {
        const ref = useRef(null);
        const chartRef = useRef(null);

        useEffect(() => {
          if (!ref.current) return;

          if (chartRef.current) {
            chartRef.current.destroy();
            chartRef.current = null;
          }

          const ctx = ref.current.getContext("2d");
          chartRef.current = new Chart(ctx, config);

          return () => {
            if (chartRef.current) {
              chartRef.current.destroy();
              chartRef.current = null;
            }
          };
        }, [config]);

        return <canvas ref={ref} role="img" aria-label={ariaLabel}></canvas>;
      }

      /***************
       * UI
       ***************/
      function MonthInput({ value, onChange, min, max }) {
        return (
          <input
            type="month"
            value={value}
            min={min}
            max={max}
            onChange={(e) => onChange(e.target.value)}
          />
        );
      }

      function defaultProdStartForIndex(i) {
        // Spread across Oct/Nov/Dec 2027 by default (editable)
        if (i < 4) return "2027-10";
        if (i < 8) return "2027-11";
        return "2027-12";
      }

      function clampCars(target, deal, existing) {
        const next = [];
        for (let i = 0; i < target; i++) {
          const id = i + 1;
          const prev = existing[i];
          if (prev) {
            next.push({ ...prev, id });
          } else {
            const prodStartMonth = defaultProdStartForIndex(i);
            next.push({
              id,
              saleMonth: "2026-03",
              prodStartMonth,
              lateMonths: 0,
            });
          }
        }
        return next;
      }

      function App() {
        const [deal, setDeal] = useState({
          numCars: 12,
          buildMonths: 4,
          annualRate: 0.085,
          startMonth: "2026-01",
        });

        const [cars, setCars] = useState(() =>
          clampCars(12, { numCars: 12, buildMonths: 4, annualRate: 0.085, startMonth: "2026-01" }, [])
        );

        const [showCumInterestOnChart1, setShowCumInterestOnChart1] = useState(false);

        function applyDealPatch(patch) {
          const nextDeal = { ...deal, ...patch };
          setDeal(nextDeal);
          setCars((prev) => clampCars(nextDeal.numCars, nextDeal, prev));
        }

        function updateCar(id, patch) {
          setCars((prev) => prev.map((c) => (c.id === id ? { ...c, ...patch } : c)));
        }

        const { monthly, ledger, kpis } = useMemo(() => buildCashflow(deal, cars), [deal, cars]);

        const dueLeadMonths = 1;
        const d2DepositMonth = "2026-07";
        const dueD2 = addMonths(d2DepositMonth, -dueLeadMonths);

        // Month map for roll-forward lookups
        const monthMap = useMemo(() => {
          const m = new Map();
          for (const r of monthly) m.set(r.month, r);
          return m;
        }, [monthly]);

        /***************
         * Chart 1 config
         * Added: a BRIGHT GREEN line for "Cumulative Profit (Rebates)" on RHS
         ***************/
        const chart1Config = useMemo(() => {
          const labels = monthly.map((r) => toMM(r.month));
          const netExposure = monthly.map((r) => r.netExposureUnfinanced);
          const debt = monthly.map((r) => r.debtEOM);

          const cumRebates = monthly.map((r) => r.cumRebatesIn);
          const cumInterest = monthly.map((r) => r.cumInterestPaid);

          const datasets = [
            {
              type: "line",
              label: "Net Exposure (Unfinanced) — LHS",
              data: netExposure,
              yAxisID: "y",
              tension: 0.25,
              borderWidth: 2,
              pointRadius: 0,
            },
            {
              type: "line",
              label: "Debt Outstanding (EOM) — LHS",
              data: debt,
              yAxisID: "y",
              tension: 0.25,
              borderWidth: 2,
              pointRadius: 0,
              borderDash: [6, 4],
            },
            {
              type: "line",
              // Requested bright green "light" for cumulative profit (rebates)
              label: "Cumulative Profit (Rebates) — RHS",
              data: cumRebates,
              yAxisID: "y1",
              tension: 0.25,
              borderWidth: 3,
              pointRadius: 0,
              borderColor: "#00C853",  // bright green
            },
          ];

          if (showCumInterestOnChart1) {
            datasets.push({
              type: "line",
              label: "Cumulative Interest Paid — RHS",
              data: cumInterest,
              yAxisID: "y1",
              tension: 0.25,
              borderWidth: 2,
              pointRadius: 0,
              borderDash: [2, 3],
            });
          }

          return {
            type: "line",
            data: { labels, datasets },
            options: {
              responsive: true,
              maintainAspectRatio: false,
              interaction: { mode: "index", intersect: false },
              plugins: {
                legend: { position: "bottom" },
                tooltip: { callbacks: { label: (ctx) => `${ctx.dataset.label}: ${gbp(ctx.parsed.y)}` } },
              },
              scales: {
                x: { ticks: { maxRotation: 0, autoSkip: true, maxTicksLimit: 10 }, grid: { display: false } },
                y: { title: { display: true, text: "LHS: Funding / Exposure" }, ticks: { callback: (v) => gbp(Number(v)) } },
                y1: {
                  position: "right",
                  title: { display: true, text: "RHS: Cumulative Profit / Interest" },
                  grid: { drawOnChartArea: false },
                  ticks: { callback: (v) => gbp(Number(v)) },
                },
              },
            },
          };
        }, [monthly, showCumInterestOnChart1]);

        /***************
         * Chart 2 config (unchanged)
         ***************/
        const chart2Config = useMemo(() => {
          const labels = monthly.map((r) => toMM(r.month));

          const cust = [];
          const rebates = [];
          const mfg = [];
          const interest = [];
          const debt = [];

          for (let i = 0; i < monthly.length; i++) {
            const cur = monthly[i];
            const prev = i === 0 ? null : monthly[i - 1];

            const dCust = cur.cumCustomerIn - (prev ? prev.cumCustomerIn : 0);
            const dReb = cur.cumRebatesIn - (prev ? prev.cumRebatesIn : 0);
            const dMfgOut = cur.cumMfgOut - (prev ? prev.cumMfgOut : 0);
            const dInt = cur.cumInterestPaid - (prev ? prev.cumInterestPaid : 0);

            cust.push(dCust);
            rebates.push(dReb);
            mfg.push(-dMfgOut);
            interest.push(-dInt);
            debt.push(cur.debtEOM);
          }

          return {
            type: "bar",
            data: {
              labels,
              datasets: [
                { type: "bar", label: "Customer Receipts — LHS", data: cust, stack: "cashflow", borderWidth: 0 },
                { type: "bar", label: "Rebates — LHS", data: rebates, stack: "cashflow", borderWidth: 0 },
                { type: "bar", label: "Manufacturer Deposits — LHS", data: mfg, stack: "cashflow", borderWidth: 0 },
                { type: "bar", label: "Interest Paid — LHS", data: interest, stack: "cashflow", borderWidth: 0 },
                { type: "line", label: "Debt (EOM) — RHS", data: debt, yAxisID: "y1", tension: 0.25, borderWidth: 2, pointRadius: 0 },
              ],
            },
            options: {
              responsive: true,
              maintainAspectRatio: false,
              interaction: { mode: "index", intersect: false },
              plugins: {
                legend: { position: "bottom" },
                tooltip: { callbacks: { label: (ctx) => `${ctx.dataset.label}: ${gbp(ctx.parsed.y)}` } },
              },
              scales: {
                x: { stacked: true, ticks: { maxRotation: 0, autoSkip: true, maxTicksLimit: 10 }, grid: { display: false } },
                y: { stacked: true, title: { display: true, text: "LHS: Monthly Cashflow" }, ticks: { callback: (v) => gbp(Number(v)) } },
                y1: {
                  position: "right",
                  title: { display: true, text: "RHS: Debt Outstanding" },
                  grid: { drawOnChartArea: false },
                  ticks: { callback: (v) => gbp(Number(v)) },
                },
              },
            },
          };
        }, [monthly]);

        /***************
         * Feb–Dec 2026 pivot summary (months as columns, rows as lines)
         * Change requested: Split "Deposits collected" into D1 and D2 rows.
         ***************/
        const febDecMonths = useMemo(() => {
          const months = [];
          let m = "2026-02";
          while (m <= "2026-12") {
            months.push(m);
            m = addMonths(m, 1);
          }
          return months;
        }, []);

        const febDecPivot = useMemo(() => {
          const safe = (x) => (x == null ? 0 : x);

          // Cars sold count by month (sale month)
          const soldByMonth = {};
          for (const c of cars) {
            soldByMonth[c.saleMonth] = (soldByMonth[c.saleMonth] || 0) + 1;
          }

          // Build per-month cashflow components from monthly roll-forward deltas
          const flowByMonth = {};
          for (const m of febDecMonths) {
            const cur = monthMap.get(m);
            const prev = monthMap.get(addMonths(m, -1));

            const curD1 = safe(cur?.cumCustD1);
            const curD2 = safe(cur?.cumCustD2);
            const curMfg = safe(cur?.cumMfgOut);
            const curReb = safe(cur?.cumRebatesIn);

            const prevD1 = safe(prev?.cumCustD1);
            const prevD2 = safe(prev?.cumCustD2);
            const prevMfg = safe(prev?.cumMfgOut);
            const prevReb = safe(prev?.cumRebatesIn);

            const d1 = curD1 - prevD1;        // customer deposits collected — D1 (monthly)
            const d2 = curD2 - prevD2;        // customer deposits collected — D2 (monthly)
            const mfg = -(curMfg - prevMfg);  // manufacturer deposits (negative cashflow)
            const reb = curReb - prevReb;     // rebates (positive)

            const net = d1 + d2 + reb + mfg;  // net cashflow line (same structure as last night's version)

            const begExp = safe(prev?.netExposureUnfinanced);
            const endExp = safe(cur?.netExposureUnfinanced);

            flowByMonth[m] = { d1, d2, mfg, reb, net, begExp, endExp };
          }

          const rows = [
            {
              label: "Cars sold (#)",
              kind: "int",
              values: febDecMonths.map((m) => soldByMonth[m] || 0),
            },
            {
              label: "Deposits collected — D1 (customers, £)",
              kind: "gbp",
              values: febDecMonths.map((m) => flowByMonth[m].d1),
            },
            {
              label: "Deposits collected — D2 (customers, £)",
              kind: "gbp",
              values: febDecMonths.map((m) => flowByMonth[m].d2),
            },
            {
              label: "Deposits made to GMA (manufacturer, £)",
              kind: "gbp",
              values: febDecMonths.map((m) => flowByMonth[m].mfg),
            },
            {
              label: "Rebates collected (manufacturer, £)",
              kind: "gbp",
              values: febDecMonths.map((m) => flowByMonth[m].reb),
            },
            {
              label: "Net cashflow this month (£)",
              kind: "gbp",
              values: febDecMonths.map((m) => flowByMonth[m].net),
            },
            {
              label: "Beginning exposure (£)",
              kind: "gbp",
              values: febDecMonths.map((m) => flowByMonth[m].begExp),
            },
            {
              label: "Ending exposure (£)",
              kind: "gbp",
              values: febDecMonths.map((m) => flowByMonth[m].endExp),
            },
          ];

          return { months: febDecMonths, rows };
        }, [febDecMonths, monthMap, cars]);

        return (
          <div className="page">
            <div className="row">
              <div>
                <h1>Deal Cashflow Model (single HTML file + charts + sliders)</h1>
                <div className="small">
                  Sale Month is a per-car slider (Mar–Sep 2026). Late Months is a per-car slider (0–3) applied to <b>D2, D3, and D4</b> customer payments.
                  Customer due dates are always 1 month ahead of each manufacturer deposit month. All month-based events occur on the <b>15th</b>.
                  Interest accrues daily on <b>ACT/365F</b> and is paid month-end.
                </div>
              </div>

              <div className="controls">
                <label className="small">
                  # Cars
                  <input
                    type="number"
                    min="1"
                    value={deal.numCars}
                    onChange={(e) => applyDealPatch({ numCars: Math.max(1, Number(e.target.value || 1)) })}
                    style={{ width: 100 }}
                  />
                </label>

                <label className="small">
                  Build months
                  <input
                    type="number"
                    min="1"
                    value={deal.buildMonths}
                    onChange={(e) => applyDealPatch({ buildMonths: Math.max(1, Number(e.target.value || 1)) })}
                    style={{ width: 120 }}
                  />
                </label>

                <label className="small">
                  Debt rate (annual)
                  <input
                    type="number"
                    step="0.001"
                    value={deal.annualRate}
                    onChange={(e) => applyDealPatch({ annualRate: Math.max(0, Number(e.target.value || 0)) })}
                    style={{ width: 140 }}
                  />
                </label>

                <label className="small">
                  Start month
                  <MonthInput
                    value={deal.startMonth}
                    onChange={(v) => applyDealPatch({ startMonth: v })}
                    min="2026-01"
                  />
                </label>
              </div>
            </div>

            {/* KPI panel */}
            <div className="cardRow">
              <div className="card">
                <div className="small">Peak net exposure (unfinanced)</div>
                <div className="value">{gbp(kpis.peakNetExposure.value)}</div>
                <div className="small">Month: {kpis.peakNetExposure.month}</div>
              </div>

              <div className="card">
                <div className="small">Peak debt outstanding (EOM)</div>
                <div className="value">{gbp(kpis.peakDebt.value)}</div>
                <div className="small">Month: {kpis.peakDebt.month}</div>
              </div>

              <div className="card">
                <div className="small">Total rebates received (gross profit)</div>
                <div className="value">{gbp(kpis.totalRebates)}</div>
                <div className="small">Should equal £0.5m × cars if all cars complete</div>
              </div>

              <div className="card">
                <div className="small">Total interest paid</div>
                <div className="value">{gbp(kpis.totalInterestPaid)}</div>
                <div className="small">ACT/365F, paid month-end</div>
              </div>

              <div className="card">
                <div className="small">Interest drag (interest / rebates)</div>
                <div className="value">{pct(kpis.interestAsPctOfRebates)}</div>
                <div className="small">Informational</div>
              </div>

              <div className="card">
                <div className="small">Debt cleared month</div>
                <div className="value">{kpis.debtClearedMonth || "—"}</div>
                <div className="small">First month EOM debt returns to £0</div>
              </div>
            </div>

            {/* Charts under KPI tiles */}
            <div className="chartGrid">
              <div className="chartCard">
                <div className="chartHeader">
                  <div>
                    <div className="chartTitle">Chart 1: Exposure, Debt, and Cumulative Profit</div>
                    <div className="small">Legend tags indicate which axis each series uses (LHS vs RHS). Profit line is bright green.</div>
                  </div>
                  <div className="chartTools">
                    <label className="toggleRow small" title="Show cumulative interest on Chart 1">
                      <input
                        type="checkbox"
                        checked={showCumInterestOnChart1}
                        onChange={(e) => setShowCumInterestOnChart1(e.target.checked)}
                      />
                      Show cumulative interest
                    </label>
                  </div>
                </div>
                <div className="chartCanvasWrap">
                  <ChartCanvas
                    config={chart1Config}
                    ariaLabel="Exposure, debt, cumulative rebates over time"
                  />
                </div>
                <div className="hint">
                  Net Exposure (Unfinanced) = cumulative manufacturer deposits − (cumulative customer receipts + cumulative rebates).
                </div>
              </div>

              <div className="chartCard">
                <div className="chartHeader">
                  <div>
                    <div className="chartTitle">Chart 2: Monthly Cashflow Bridge (Stacked) + Debt Overlay</div>
                    <div className="small">Bars (LHS) show monthly inflows/outflows; the line (RHS) shows end-of-month debt.</div>
                  </div>
                </div>
                <div className="chartCanvasWrap">
                  <ChartCanvas
                    config={chart2Config}
                    ariaLabel="Monthly cashflows with debt overlay"
                  />
                </div>
                <div className="hint">
                  Positive bars are receipts (customers + rebates). Negative bars are payments (manufacturer deposits + interest).
                </div>
              </div>
            </div>

            {/* Feb–Dec 2026 pivot summary */}
            <div className="section">
              <div className="sectionTitle">Feb–Dec 2026 Summary (Monthly Cashflow + Exposure Roll-Forward)</div>
              <div className="tableWrap">
                <table>
                  <thead>
                    <tr>
                      <th>Metric</th>
                      {febDecPivot.months.map((m) => (
                        <th key={m} className="right mono">{m}</th>
                      ))}
                    </tr>
                  </thead>
                  <tbody>
                    {febDecPivot.rows.map((r) => (
                      <tr key={r.label}>
                        <td style={{ fontWeight: 600 }}>{r.label}</td>
                        {r.values.map((v, i) => (
                          <td key={i} className="right">
                            {r.kind === "int" ? String(v) : gbp(v)}
                          </td>
                        ))}
                      </tr>
                    ))}
                  </tbody>
                </table>
              </div>

              <div className="small" style={{ marginTop: 8 }}>
                Sign convention: Deposits collected and rebates are positive. Deposits made to GMA are negative.
                Net cashflow = (D1 deposits + D2 deposits + rebates + manufacturer deposits).
                Exposure is positive when you are out cash.
              </div>
            </div>

            {/* Per-car schedule (simplified inputs) */}
            <div className="section">
              <div className="row">
                <div className="sectionTitle">Per-car schedule (simplified inputs)</div>
                <div className="badgeRow">
                  <span className="badge">Sale Month slider range: Mar–Sep 2026</span>
                  <span className="badge">Late Months slider range: 0–3 (applies to D2/D3/D4)</span>
                  <span className="badge">Customer Due Lead: {1} month ahead</span>
                  <span className="badge">Customer D2 Due Month (all cars): {dueD2}</span>
                  <span className="badge">MFG D1: 2026-02-01</span>
                  <span className="badge">MFG D2: 2026-07-15</span>
                </div>
              </div>

              <div className="tableWrap" style={{ marginTop: 10 }}>
                <table>
                  <thead>
                    <tr>
                      <th>Car</th>
                      <th>Sale Month (slider)</th>
                      <th>Late Months (slider)</th>
                      <th>Prod Start Month</th>
                      <th>Delivery Month</th>
                      <th>Due Months (D2 / D3 / D4)</th>
                      <th>Paid Months (D2 / D3 / D4)</th>
                    </tr>
                  </thead>
                  <tbody>
                    {cars.map((c) => {
                      const { dueD2, dueD3, dueD4, deliveryMonth } = computeDueMonths(deal, c.prodStartMonth);
                      const paidD2 = paidFromDueAndLate(dueD2, c.lateMonths);
                      const paidD3 = paidFromDueAndLate(dueD3, c.lateMonths);
                      const paidD4 = paidFromDueAndLate(dueD4, c.lateMonths);

                      return (
                        <tr key={c.id}>
                          <td className="mono">{c.id}</td>

                          <td>
                            <div className="sliderWrap">
                              <div className="sliderRow">
                                <input
                                  type="range"
                                  min="0"
                                  max={String(SALE_MONTHS.length - 1)}
                                  step="1"
                                  value={saleIndexFromMonth(c.saleMonth)}
                                  onChange={(e) => updateCar(c.id, { saleMonth: saleMonthFromIndex(e.target.value) })}
                                />
                                <span className="pill">
                                  <span className="sliderValue">{c.saleMonth}</span>
                                </span>
                              </div>
                              <div className="mini tight">
                                Customer D1 (£1m) received on <b>{c.saleMonth}-15</b>.
                              </div>
                            </div>
                          </td>

                          <td>
                            <div className="sliderWrap">
                              <div className="sliderRow">
                                <input
                                  type="range"
                                  min="0"
                                  max="3"
                                  step="1"
                                  value={c.lateMonths}
                                  onChange={(e) => updateCar(c.id, { lateMonths: Number(e.target.value) })}
                                />
                                <span className="pill">
                                  <span className="sliderValue">{c.lateMonths}</span> mo
                                </span>
                              </div>
                              <div className="mini tight">
                                Applies to customer D2/D3/D4: Paid = Due + Late Months.
                              </div>
                            </div>
                          </td>

                          <td>
                            <MonthInput value={c.prodStartMonth} onChange={(v) => updateCar(c.id, { prodStartMonth: v })} />
                            <div className="small tight" style={{ marginTop: 6 }}>
                              D3 due at start (15th); P3 rebate +14 days.
                            </div>
                          </td>

                          <td>
                            <div style={{ fontWeight: 600 }}>{deliveryMonth}</div>
                            <div className="small tight" style={{ marginTop: 6 }}>
                              Delivery = start + {deal.buildMonths}m (15th); P4 rebate +14 days.
                            </div>
                          </td>

                          <td className="mono">
                            <div>D2 due: {dueD2}</div>
                            <div>D3 due: {dueD3}</div>
                            <div>D4 due: {dueD4}</div>
                          </td>

                          <td className="mono">
                            <div>D2 paid: {paidD2}</div>
                            <div>D3 paid: {paidD3}</div>
                            <div>D4 paid: {paidD4}</div>
                          </td>
                        </tr>
                      );
                    })}
                  </tbody>
                </table>
              </div>

              <div className="small" style={{ marginTop: 8 }}>
                Note: “Paid Months” are derived from sliders. This version is intentionally streamlined.
              </div>
            </div>

            {/* Monthly outputs (end-of-month) */}
            <div className="section">
              <div className="sectionTitle">Monthly outputs (end-of-month)</div>
              <div className="tableWrap">
                <table>
                  <thead>
                    <tr>
                      <th>Month</th>
                      <th className="right">Cash (EOM)</th>
                      <th className="right">Debt (EOM)</th>
                      <th className="right">Net exposure (unfinanced)</th>
                      <th className="right">Cum customer receipts</th>
                      <th className="right">Cum mfg deposits</th>
                      <th className="right">Cum rebates</th>
                      <th className="right">Cum interest paid</th>
                    </tr>
                  </thead>
                  <tbody>
                    {monthly.map((r) => (
                      <tr key={r.month}>
                        <td className="mono">{r.month}</td>
                        <td className="right">{gbp(r.cashEOM)}</td>
                        <td className="right">{gbp(r.debtEOM)}</td>
                        <td className="right">{gbp(r.netExposureUnfinanced)}</td>
                        <td className="right">{gbp(r.cumCustomerIn)}</td>
                        <td className="right">{gbp(r.cumMfgOut)}</td>
                        <td className="right">{gbp(r.cumRebatesIn)}</td>
                        <td className="right">{gbp(r.cumInterestPaid)}</td>
                      </tr>
                    ))}
                  </tbody>
                </table>
              </div>
              <div className="small" style={{ marginTop: 8 }}>
                Net exposure (unfinanced) = cumulative manufacturer deposits − (cumulative customer receipts + cumulative rebates).
              </div>
            </div>

            {/* Audit ledger */}
            <div className="section">
              <details>
                <summary className="sectionTitle">Audit ledger (chronological)</summary>
                <div className="tableWrap" style={{ marginTop: 10 }}>
                  <table>
                    <thead>
                      <tr>
                        <th>Date</th>
                        <th>Type</th>
                        <th>Label</th>
                        <th className="right">Amount</th>
                        <th className="right">Cash after</th>
                        <th className="right">Debt after</th>
                      </tr>
                    </thead>
                    <tbody>
                      {ledger.map((r, idx) => (
                        <tr key={idx}>
                          <td className="mono">{r.dateISO}</td>
                          <td className="mono">{r.type}</td>
                          <td>{r.label}</td>
                          <td className="right">{gbp(r.amount)}</td>
                          <td className="right">{gbp(r.cashAfter)}</td>
                          <td className="right">{gbp(r.debtAfter)}</td>
                        </tr>
                      ))}
                    </tbody>
                  </table>
                </div>
              </details>
            </div>

            <div className="section small">
              Hosting note: commit this as <span className="mono">index.html</span> in a GitHub repo and enable GitHub Pages. It will run as-is (no build step).
            </div>
          </div>
        );
      }

      const root = ReactDOM.createRoot(document.getElementById("root"));
      root.render(<App />);
    </script>
  </body>
</html>
