<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Deal Cashflow Model (Single-File + Scenarios)</title>

    <!-- React + ReactDOM (UMD) -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>

    <!-- Babel (so you can run JSX in a single HTML file) -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <!-- Chart.js (UMD) -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>

    <style>
      :root {
        --border: #ddd;
        --border2: #eee;
        --text: #111;
        --muted: #555;
        --bg: #fff;
        --good: #0b7a2a;
        --bad: #b00020;
      }
      body {
        margin: 0;
        background: #fafafa;
        color: var(--text);
        font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      }
      .page {
        padding: 18px;
        max-width: 1500px;
        margin: 0 auto;
      }
      .row {
        display: flex;
        gap: 12px;
        flex-wrap: wrap;
        align-items: center;
      }
      h1 {
        margin: 0;
        font-size: 18px;
      }
      .small {
        color: var(--muted);
        font-size: 12px;
      }
      .controls {
        margin-left: auto;
        display: flex;
        gap: 10px;
        flex-wrap: wrap;
        align-items: flex-end;
      }
      label {
        display: inline-flex;
        flex-direction: column;
        gap: 4px;
      }
      input[type="number"],
      input[type="month"],
      input[type="checkbox"],
      select,
      button {
        padding: 6px 8px;
        border: 1px solid var(--border);
        border-radius: 10px;
        background: var(--bg);
        font: inherit;
      }
      input[type="checkbox"] {
        width: 16px;
        height: 16px;
        padding: 0;
        border-radius: 4px;
      }
      button {
        cursor: pointer;
      }
      button:disabled {
        cursor: not-allowed;
        opacity: 0.5;
      }
      input[type="range"] {
        width: 220px;
      }

      .cardRow {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
        gap: 12px;
        margin-top: 14px;
      }
      .card {
        border: 1px solid var(--border);
        border-radius: 12px;
        padding: 12px;
        background: var(--bg);
      }
      .card .value {
        font-size: 20px;
        margin-top: 6px;
      }

      .badgeRow {
        display: flex;
        gap: 8px;
        flex-wrap: wrap;
        align-items: center;
      }
      .badge {
        display: inline-block;
        padding: 2px 8px;
        border-radius: 999px;
        border: 1px solid var(--border);
        font-size: 12px;
        color: #333;
        background: var(--bg);
      }

      .section {
        margin-top: 18px;
      }
      .sectionTitle {
        font-weight: 600;
        margin-bottom: 8px;
      }
      .tableWrap {
        overflow-x: auto;
        border: 1px solid var(--border);
        border-radius: 12px;
        background: var(--bg);
      }
      table {
        width: 100%;
        border-collapse: collapse;
      }
      th {
        text-align: left;
        border-bottom: 1px solid var(--border);
        padding: 8px 6px;
        font-size: 12px;
        color: #444;
        background: #fcfcfc;
        white-space: nowrap;
      }
      td {
        border-bottom: 1px solid var(--border2);
        padding: 8px 6px;
        vertical-align: top;
        font-size: 13px;
      }
      tr:last-child td {
        border-bottom: none;
      }
      details summary {
        cursor: pointer;
      }
      .right {
        text-align: right;
      }
      .mono {
        font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono",
          "Courier New", monospace;
      }

      /* Charts */
      .chartGrid {
        display: grid;
        grid-template-columns: 1fr;
        gap: 12px;
        margin-top: 12px;
      }
      @media (min-width: 1100px) {
        .chartGrid {
          grid-template-columns: 1fr 1fr;
        }
      }
      .chartCard {
        border: 1px solid var(--border);
        border-radius: 12px;
        padding: 12px;
        background: var(--bg);
      }
      .chartHeader {
        display: flex;
        align-items: flex-end;
        justify-content: space-between;
        gap: 12px;
        flex-wrap: wrap;
        margin-bottom: 8px;
      }
      .chartTitle {
        font-weight: 600;
      }
      .chartTools {
        display: flex;
        gap: 10px;
        align-items: center;
        flex-wrap: wrap;
      }
      .chartCanvasWrap {
        position: relative;
        height: 340px;
      }
      @media (min-width: 1100px) {
        .chartCanvasWrap {
          height: 360px;
        }
      }
      .hint {
        color: var(--muted);
        font-size: 12px;
        margin-top: 8px;
        line-height: 1.35;
      }
      .toggleRow {
        display: inline-flex;
        gap: 8px;
        align-items: center;
        user-select: none;
      }

      /* Slider UI */
      .sliderWrap {
        display: flex;
        flex-direction: column;
        gap: 6px;
        min-width: 280px;
      }
      .sliderRow {
        display: flex;
        gap: 10px;
        align-items: center;
        flex-wrap: wrap;
      }
      .pill {
        display: inline-block;
        padding: 2px 8px;
        border-radius: 999px;
        border: 1px solid var(--border);
        background: #fff;
        font-size: 12px;
      }
      .mini {
        font-size: 11px;
        color: var(--muted);
        line-height: 1.25;
      }
      .tight {
        line-height: 1.25;
      }

      /* 2026 summary table styling */
      .rowGood td,
      .rowGood th {
        color: var(--good);
      }
      .rowBad td,
      .rowBad th {
        color: var(--bad);
      }
      .rowLabel {
        position: sticky;
        left: 0;
        background: #fff;
        z-index: 2;
        border-right: 1px solid var(--border2);
        min-width: 220px;
      }
      .sumBlock .rowLabel { background: #fcfcfc; }
.sumBlue  .rowLabel { background: #e8f3ff; }
      .rowLabelHead {
        position: sticky;
        left: 0;
        z-index: 3;
      }
      .sumBlock {
  background: #fcfcfc;
}

.sumBlue {
  background: #e8f3ff;
}
    </style>
  </head>

  <body>
    <div id="root"></div>

    <script type="text/babel">
      const { useMemo, useState, useEffect, useRef } = React;

      /***************
       * Utilities
       ***************/
      const GBP = 1_000_000;

      function pad2(n) {
        return String(n).padStart(2, "0");
      }

      function gbp(n) {
        const sign = n < 0 ? "-" : "";
        const abs = Math.abs(n);
        return sign + "£" + abs.toLocaleString(undefined, { maximumFractionDigits: 0 });
      }

      function pct(n) {
        return (n * 100).toFixed(1) + "%";
      }

      // MonthStr is "YYYY-MM"
      function monthToYMD(month) {
        const [yStr, mStr] = month.split("-");
        return { y: Number(yStr), m: Number(mStr) }; // m: 1-12
      }

      function fmtMonth(y, m) {
        return `${y}-${pad2(m)}`;
      }

      function addMonths(month, delta) {
        const { y, m } = monthToYMD(month);
        let total = y * 12 + (m - 1) + delta;
        const ny = Math.floor(total / 12);
        const nm0 = total % 12;
        const nm = nm0 + 1;
        return fmtMonth(ny, nm);
      }

      function dateUTC(y, m, d) {
        return new Date(Date.UTC(y, m - 1, d));
      }

      function monthDate15(month) {
        const { y, m } = monthToYMD(month);
        return dateUTC(y, m, 15);
      }

      function addDaysUTC(d, days) {
        const nd = new Date(d.getTime());
        nd.setUTCDate(nd.getUTCDate() + days);
        return nd;
      }

      function toISODate(d) {
        const y = d.getUTCFullYear();
        const m = pad2(d.getUTCMonth() + 1);
        const day = pad2(d.getUTCDate());
        return `${y}-${m}-${day}`;
      }

      function monthFromISODate(iso) {
        // iso: YYYY-MM-DD
        return iso.slice(0, 7);
      }

      function isMonthEndUTC(d) {
        const next = addDaysUTC(d, 1);
        return next.getUTCMonth() !== d.getUTCMonth();
      }

      function endOfMonthUTC(month) {
        const { y, m } = monthToYMD(month);
        const firstNext = m === 12 ? dateUTC(y + 1, 1, 1) : dateUTC(y, m + 1, 1);
        return addDaysUTC(firstNext, -1);
      }

      // Slider mapping: March..September 2026
      const SALE_MONTHS = ["2026-03","2026-04","2026-05","2026-06","2026-07","2026-08","2026-09"];

      function saleIndexFromMonth(month) {
        const idx = SALE_MONTHS.indexOf(month);
        return idx >= 0 ? idx : 0;
      }
      function saleMonthFromIndex(i) {
        const idx = Math.min(Math.max(Number(i), 0), SALE_MONTHS.length - 1);
        return SALE_MONTHS[idx];
      }

      function monthRange(startMonth, endMonth) {
        // inclusive list of months YYYY-MM
        const out = [];
        let cur = startMonth;
        while (cur <= endMonth) {
          out.push(cur);
          cur = addMonths(cur, 1);
        }
        return out;
      }

      /***************
       * Deterministic RNG (Scenario 1 lateness assignment)
       ***************/
      function lcg(seed) {
        let s = seed >>> 0;
        return function rand() {
          // Numerical Recipes LCG
          s = (1664525 * s + 1013904223) >>> 0;
          return s / 4294967296;
        };
      }

      function seededShuffle(arr, seed) {
        const a = arr.slice();
        const r = lcg(seed);
        for (let i = a.length - 1; i > 0; i--) {
          const j = Math.floor(r() * (i + 1));
          [a[i], a[j]] = [a[j], a[i]];
        }
        return a;
      }

      /***************
       * Model logic
       ***************/
      function typePriority(t) {
        // 1) Customer receipts 2) Manufacturer deposits 3) Rebates 4) Sweep/draw 5) Month-end interest
        switch (t) {
          case "CUST_IN":
            return 1;
          case "MFG_OUT":
            return 2;
          case "REBATE_IN":
            return 3;
          case "DEBT_REPAY":
            return 4;
          case "DEBT_DRAW":
            return 4;
          case "INT_PAID":
            return 5;
          default:
            return 99;
        }
      }

      function computeDueMonths(deal, prodStartMonth) {
        // Customer due lead is fixed at 1 month ahead
        const d2DepositMonth = "2026-07"; // manufacturer D2 month
        const dueD2 = addMonths(d2DepositMonth, -1); // June 2026
        const dueD3 = addMonths(prodStartMonth, -1);
        const deliveryMonth = addMonths(prodStartMonth, deal.buildMonths);
        const dueD4 = addMonths(deliveryMonth, -1);
        return { dueD2, dueD3, dueD4, deliveryMonth };
      }

      function paidFromDueAndLate(dueMonth, lateMonths) {
        return addMonths(dueMonth, lateMonths);
      }

      function buildCashflow(deal, cars) {
        const numCars = cars.length;

        // per car deposits
        const D1 = 1 * GBP;
        const D2 = 1 * GBP;
        const D3 = 1 * GBP;
        const D4 = 2 * GBP;

        // rebates: 10% of each deposit; P4 = 10% of D4 (0.2m)
        const R1 = 0.1 * GBP;
        const R2 = 0.1 * GBP;
        const R3 = 0.1 * GBP;
        const R4 = 0.2 * GBP;

        const raw = [];

        // Fixed manufacturer deposits (portfolio-level)
        raw.push({
          date: dateUTC(2026, 2, 1),
          type: "MFG_OUT",
          label: "Manufacturer D1 (all cars)",
          amount: -(D1 * numCars),
        });
        raw.push({
          date: dateUTC(2026, 7, 15),
          type: "MFG_OUT",
          label: "Manufacturer D2 (all cars)",
          amount: -(D2 * numCars),
        });

        // Fixed rebates (portfolio-level)
        raw.push({
          date: dateUTC(2026, 5, 15),
          type: "REBATE_IN",
          label: "Rebate P1 = 10% of D1 (all cars)",
          amount: +(R1 * numCars),
        });
        raw.push({
          date: dateUTC(2026, 8, 1),
          type: "REBATE_IN",
          label: "Rebate P2 = 10% of D2 (all cars)",
          amount: +(R2 * numCars),
        });

        // Per-car events
        for (const c of cars) {
          // Customer D1 on sale date (15th)
          raw.push({
            date: monthDate15(c.saleMonth),
            type: "CUST_IN",
            tranche: "D1",
            label: `Car ${c.id}: Customer D1 receipt`,
            amount: +D1,
          });

          const { dueD2, dueD3, dueD4 } = computeDueMonths(deal, c.prodStartMonth);

          // Paid months are due month + lateMonths (lateMonths applies to D2/D3/D4)
          const paidD2Month = paidFromDueAndLate(dueD2, c.lateMonths);
          const paidD3Month = paidFromDueAndLate(dueD3, c.lateMonths);
          const paidD4Month = paidFromDueAndLate(dueD4, c.lateMonths);

          // Customer receipts staged
          raw.push({
            date: monthDate15(paidD2Month),
            type: "CUST_IN",
            tranche: "D2",
            label: `Car ${c.id}: Customer D2 receipt (late ${c.lateMonths}m)`,
            amount: +D2,
          });
          raw.push({
            date: monthDate15(paidD3Month),
            type: "CUST_IN",
            tranche: "D3",
            label: `Car ${c.id}: Customer D3 receipt (late ${c.lateMonths}m)`,
            amount: +D3,
          });
          raw.push({
            date: monthDate15(paidD4Month),
            type: "CUST_IN",
            tranche: "D4",
            label: `Car ${c.id}: Customer D4 receipt (late ${c.lateMonths}m)`,
            amount: +D4,
          });

          const prodStart = monthDate15(c.prodStartMonth);
          const deliveryMonth = addMonths(c.prodStartMonth, deal.buildMonths);
          const deliveryDate = monthDate15(deliveryMonth);

          // Manufacturer D3 / D4
          raw.push({
            date: prodStart,
            type: "MFG_OUT",
            label: `Car ${c.id}: Manufacturer D3`,
            amount: -D3,
          });
          raw.push({
            date: deliveryDate,
            type: "MFG_OUT",
            label: `Car ${c.id}: Manufacturer D4 (delivery)`,
            amount: -D4,
          });

          // Rebates P3/P4 = +14 days
          raw.push({
            date: addDaysUTC(prodStart, 14),
            type: "REBATE_IN",
            label: `Car ${c.id}: Rebate P3 = 10% of D3`,
            amount: +R3,
          });
          raw.push({
            date: addDaysUTC(deliveryDate, 14),
            type: "REBATE_IN",
            label: `Car ${c.id}: Rebate P4 = 10% of D4`,
            amount: +R4,
          });
        }

        // Determine sim window: start at deal.startMonth (1st day), end at max event month + 2
        const { y: sy, m: sm } = monthToYMD(deal.startMonth);
        const minDate = dateUTC(sy, sm, 1);

        let maxEventDate = minDate;
        for (const e of raw) {
          if (e.date > maxEventDate) maxEventDate = e.date;
        }
        const maxMonth = fmtMonth(maxEventDate.getUTCFullYear(), maxEventDate.getUTCMonth() + 1);
        const simEndMonth = addMonths(maxMonth, 2);
        const simEndDate = endOfMonthUTC(simEndMonth);

        // Group events by date
        const byDate = new Map();
        for (const e of raw) {
          const key = toISODate(e.date);
          if (!byDate.has(key)) byDate.set(key, []);
          byDate.get(key).push(e);
        }
        for (const [k, arr] of byDate.entries()) {
          arr.sort((a, b) => typePriority(a.type) - typePriority(b.type));
          byDate.set(k, arr);
        }

        // State
        let cash = 0;
        let debt = 0;
        let accruedInterestThisMonth = 0;

        let cumCustomerIn = 0;
        let cumMfgOut = 0;
        let cumRebatesIn = 0;
        let cumInterestPaid = 0;

        const ledger = [];
        const monthly = [];

        function record(dateISO, type, label, amount, tranche) {
          ledger.push({
            dateISO,
            type,
            tranche: tranche || null,
            label,
            amount,
            cashAfter: cash,
            debtAfter: debt,
          });
        }

        function drawIfNeeded(dateISO, context) {
          if (cash < 0) {
            const draw = -cash;
            debt += draw;
            cash = 0;
            record(dateISO, "DEBT_DRAW", `Debt draw (to fund ${context})`, +draw);
          }
        }

        function sweep(dateISO) {
          if (cash > 0 && debt > 0) {
            const repay = Math.min(cash, debt);
            cash -= repay;
            debt -= repay;
            record(dateISO, "DEBT_REPAY", "Debt repay (cash sweep)", -repay);
          }
        }

        // Iterate day-by-day UTC
        let d = new Date(minDate.getTime());
        while (d <= simEndDate) {
          const dateISO = toISODate(d);
          const todays = byDate.get(dateISO) || [];

          for (const e of todays) {
            cash += e.amount;

            if (e.type === "CUST_IN") cumCustomerIn += e.amount;
            if (e.type === "MFG_OUT") cumMfgOut += -e.amount; // store positive outflow
            if (e.type === "REBATE_IN") cumRebatesIn += e.amount;

            record(dateISO, e.type, e.label, e.amount, e.tranche);
            drawIfNeeded(dateISO, e.label);
          }

          // sweep same day
          sweep(dateISO);

          // daily interest accrual on end-of-day debt (ACT/365F)
          const dailyRate = deal.annualRate / 365.0;
          accruedInterestThisMonth += debt * dailyRate;

          // pay interest at month-end
          if (isMonthEndUTC(d)) {
            if (accruedInterestThisMonth > 0) {
              const pay = accruedInterestThisMonth;
              cash -= pay;
              cumInterestPaid += pay;
              record(dateISO, "INT_PAID", "Interest paid (month-end, ACT/365F)", -pay);
              accruedInterestThisMonth = 0;
              drawIfNeeded(dateISO, "interest payment");
            }

            const monthStr = fmtMonth(d.getUTCFullYear(), d.getUTCMonth() + 1);
            const netExposureUnfinanced = cumMfgOut - (cumCustomerIn + cumRebatesIn);

            monthly.push({
              month: monthStr,
              cashEOM: cash,
              debtEOM: debt,
              cumCustomerIn,
              cumMfgOut,
              cumRebatesIn,
              cumInterestPaid,
              netExposureUnfinanced,
            });
          }

          d = addDaysUTC(d, 1);
        }

        // KPIs
        let peakNet = { value: 0, month: monthly[0]?.month || deal.startMonth };
        let peakDebt = { value: 0, month: monthly[0]?.month || deal.startMonth };

        for (const r of monthly) {
          if (r.netExposureUnfinanced > peakNet.value) peakNet = { value: r.netExposureUnfinanced, month: r.month };
          if (r.debtEOM > peakDebt.value) peakDebt = { value: r.debtEOM, month: r.month };
        }

        const last = monthly[monthly.length - 1] || null;
        const totalRebates = last ? last.cumRebatesIn : 0;
        const totalInterestPaid = last ? last.cumInterestPaid : 0;

        let sawDebt = false;
        let debtClearedMonth = null;
        for (const r of monthly) {
          if (r.debtEOM > 0) sawDebt = true;
          if (sawDebt && r.debtEOM === 0) {
            debtClearedMonth = r.month;
            break;
          }
        }

        const profitAfterInterest = totalRebates - totalInterestPaid; // informational
        const interestAsPctOfRebates = totalRebates > 0 ? totalInterestPaid / totalRebates : 0;
        const profitOverPeakExposure = peakNet.value > 0 ? totalRebates / peakNet.value : 0;

        const kpis = {
          peakNetExposure: peakNet,
          peakDebt: peakDebt,
          totalRebates,
          totalInterestPaid,
          profitAfterInterest,
          interestAsPctOfRebates,
          profitOverPeakExposure,
          debtClearedMonth,
        };

        return { ledger, monthly, kpis };
      }

      /***************
       * Scenarios
       ***************/
      function scenario1Sales(n) {
        // Spec: 6 cars March, 4 April, 2 May (for 12). For other n: fill in order, remainder to May.
        const out = [];
        const months = ["2026-03", "2026-04", "2026-05"];
        const counts = [6, 4, 2];
        let i = 0;
        for (let m = 0; m < months.length; m++) {
          const c = (m < counts.length ? counts[m] : 0);
          for (let k = 0; k < c && i < n; k++, i++) out.push(months[m]);
        }
        while (out.length < n) out.push("2026-05");
        return out;
      }

      function scenario2Sales(n) {
        // Spec for 12: 4 Mar, 4 Apr, 2 May, 1 Jun, 1 Jul. If n>12, fill remainder with Sep.
        const base = [
          "2026-03","2026-03","2026-03","2026-03",
          "2026-04","2026-04","2026-04","2026-04",
          "2026-05","2026-05",
          "2026-06",
          "2026-07"
        ];
        const out = [];
        for (let i = 0; i < n; i++) out.push(base[i] ?? "2026-09");
        return out;
      }

      function scenario2Lateness(n) {
        const base = [0,0,1,1,2,0,1,2,0,2,0,0];
        const out = [];
        for (let i = 0; i < n; i++) out.push(base[i % base.length]);
        return out;
      }

      function scenario1LatenessDeterministic(n, seed = 1) {
        // Spec: 50% on time, 25% 1m late, 25% 2m late (rounded deterministically)
        const n0 = Math.floor(n * 0.5);
        const n1 = Math.floor(n * 0.25);
        const n2 = Math.max(0, n - n0 - n1);

        const ids = Array.from({ length: n }, (_, i) => i + 1);
        const shuffled = seededShuffle(ids, seed);

        const lateById = new Map();
        for (let i = 0; i < shuffled.length; i++) {
          const id = shuffled[i];
          let late = 0;
          if (i < n0) late = 0;
          else if (i < n0 + n1) late = 1;
          else late = 2; // remaining goes to 2 months
          lateById.set(id, late);
        }
        return ids.map((id) => lateById.get(id) ?? 0);
      }

      function defaultProdStartForIndex(i) {
        // Spread across Oct/Nov/Dec 2027 by default (editable)
        if (i < 4) return "2027-10";
        if (i < 8) return "2027-11";
        return "2027-12";
      }

      function buildCarsFromScenario(deal, scenarioName) {
        const n = deal.numCars;
        const sales = scenarioName === "Scenario 2" ? scenario2Sales(n) : scenario1Sales(n);
        const lates =
          scenarioName === "Scenario 2" ? scenario2Lateness(n) : scenario1LatenessDeterministic(n, 1);

        return Array.from({ length: n }, (_, i) => ({
          id: i + 1,
          saleMonth: sales[i],
          lateMonths: lates[i],
          prodStartMonth: defaultProdStartForIndex(i),
        }));
      }

      /***************
       * Chart helpers
       ***************/
      function toMM(m) {
        return m; // keep YYYY-MM for auditability
      }

      function ChartCanvas({ config, ariaLabel }) {
        const ref = useRef(null);
        const chartRef = useRef(null);

        useEffect(() => {
          if (!ref.current) return;

          if (chartRef.current) {
            chartRef.current.destroy();
            chartRef.current = null;
          }

          const ctx = ref.current.getContext("2d");
          chartRef.current = new Chart(ctx, config);

          return () => {
            if (chartRef.current) {
              chartRef.current.destroy();
              chartRef.current = null;
            }
          };
        }, [config]);

        return <canvas ref={ref} role="img" aria-label={ariaLabel}></canvas>;
      }

      /***************
       * 2026 Summary Table
       ***************/
      function build2026Summary(cars, ledger) {
        const months = monthRange("2026-02", "2026-12"); // Feb-Dec 2026 inclusive

        const carsSold = Object.fromEntries(months.map((m) => [m, 0]));
        for (const c of cars) {
          if (carsSold[c.saleMonth] !== undefined) carsSold[c.saleMonth] += 1;
        }

        // Split customer receipts into D1 and D2 (for Feb-Dec 2026 view)
        const depositsCollectedD1 = Object.fromEntries(months.map((m) => [m, 0]));
        const depositsCollectedD2 = Object.fromEntries(months.map((m) => [m, 0]));

        const depositsMade = Object.fromEntries(months.map((m) => [m, 0]));      // manufacturer deposits (negative)
        const rebatesCollected = Object.fromEntries(months.map((m) => [m, 0]));  // rebates landing in 2026

        function trancheFromRow(r) {
          if (r.tranche) return r.tranche;
          // fallback for robustness (in case tranche ever missing)
          if (typeof r.label === "string") {
            if (r.label.includes("Customer D1")) return "D1";
            if (r.label.includes("Customer D2")) return "D2";
          }
          return null;
        }

        for (const r of ledger) {
          const m = monthFromISODate(r.dateISO);
          if (!months.includes(m)) continue;

          if (r.type === "CUST_IN") {
            const tr = trancheFromRow(r);
            if (tr === "D1") depositsCollectedD1[m] += r.amount;
            if (tr === "D2") depositsCollectedD2[m] += r.amount;
          }
          if (r.type === "MFG_OUT") depositsMade[m] += r.amount; // already negative
          if (r.type === "REBATE_IN") rebatesCollected[m] += r.amount;
        }

        const netCashflow = Object.fromEntries(months.map((m) => [m, 0]));
        for (const m of months) {
          const depositsCollectedTotal = depositsCollectedD1[m] + depositsCollectedD2[m];
          netCashflow[m] = depositsCollectedTotal + rebatesCollected[m] + depositsMade[m];
        }

        const beginningExposure = Object.fromEntries(months.map((m) => [m, 0]));
        const endingExposure = Object.fromEntries(months.map((m) => [m, 0]));

        // Exposure convention: positive = you are out cash.
        // If net cashflow is positive (more inflow), exposure declines. So: ending = beginning - netCashflow.
        let prevEnd = 0;
        for (const m of months) {
          beginningExposure[m] = prevEnd;
          const end = prevEnd - netCashflow[m];
          endingExposure[m] = end;
          prevEnd = end;
        }

        return {
          months,
          carsSold,
          depositsCollectedD1,
          depositsCollectedD2,
          depositsMade,
          rebatesCollected,
          netCashflow,
          beginningExposure,
          endingExposure,
        };
      }

      /***************
       * UI
       ***************/
      function MonthInput({ value, onChange, min, max }) {
        return (
          <input
            type="month"
            value={value}
            min={min}
            max={max}
            onChange={(e) => onChange(e.target.value)}
          />
        );
      }

      function App() {
        const [deal, setDeal] = useState({
          numCars: 12,
          buildMonths: 4,
          annualRate: 0.085,
          startMonth: "2026-01",
        });

        const [selectedScenario, setSelectedScenario] = useState("Scenario 1");
        const [lastAppliedScenario, setLastAppliedScenario] = useState(null);

        // Initialize cars to Scenario 1 defaults (so the page loads in a meaningful state)
        const [cars, setCars] = useState(() => buildCarsFromScenario({ numCars: 12, buildMonths: 4 }, "Scenario 1"));

        const [showCumInterestOnChart1, setShowCumInterestOnChart1] = useState(false);

        function applyDealPatch(patch) {
          const nextDeal = { ...deal, ...patch };
          setDeal(nextDeal);

          // If numCars changes, preserve current cars as much as possible by clamping.
          setCars((prev) => {
            const n = nextDeal.numCars;
            const out = [];
            for (let i = 0; i < n; i++) {
              if (prev[i]) out.push({ ...prev[i], id: i + 1 });
              else out.push({ id: i + 1, saleMonth: "2026-03", lateMonths: 0, prodStartMonth: defaultProdStartForIndex(i) });
            }
            return out;
          });
        }

        function updateCar(id, patch) {
          setCars((prev) => prev.map((c) => (c.id === id ? { ...c, ...patch } : c)));
        }

        function onApplyScenario() {
          const nextCars = buildCarsFromScenario(deal, selectedScenario);
          setCars(nextCars);
          setLastAppliedScenario(selectedScenario);
        }

        function onResetToAppliedScenario() {
          if (!lastAppliedScenario) return;
          const nextCars = buildCarsFromScenario(deal, lastAppliedScenario);
          setCars(nextCars);
        }

        const { monthly, ledger, kpis } = useMemo(() => buildCashflow(deal, cars), [deal, cars]);

        const summary2026 = useMemo(() => build2026Summary(cars, ledger), [cars, ledger]);

        const dueLeadMonths = 1;
        const d2DepositMonth = "2026-07";
        const dueD2 = addMonths(d2DepositMonth, -dueLeadMonths);

        /***************
         * Chart 1 config
         ***************/
        const chart1Config = useMemo(() => {
          const labels = monthly.map((r) => toMM(r.month));
          const netExposure = monthly.map((r) => r.netExposureUnfinanced);
          const debt = monthly.map((r) => r.debtEOM);
          const cumRebates = monthly.map((r) => r.cumRebatesIn);
          const cumInterest = monthly.map((r) => r.cumInterestPaid);

          const datasets = [
            {
              type: "line",
              label: "Net Exposure (Unfinanced) — LHS",
              data: netExposure,
              yAxisID: "y",
              tension: 0.25,
              borderWidth: 2,
              pointRadius: 0,
            },
            {
              type: "line",
              label: "Debt Outstanding (EOM) — LHS",
              data: debt,
              yAxisID: "y",
              tension: 0.25,
              borderWidth: 2,
              pointRadius: 0,
              borderDash: [6, 4],
            },
            {
              type: "line",
              label: "Cumulative Rebates — RHS",
              data: cumRebates,
              yAxisID: "y1",
              tension: 0.25,
              borderWidth: 2,
              pointRadius: 0,
            },
          ];

          if (showCumInterestOnChart1) {
            datasets.push({
              type: "line",
              label: "Cumulative Interest Paid — RHS",
              data: cumInterest,
              yAxisID: "y1",
              tension: 0.25,
              borderWidth: 2,
              pointRadius: 0,
              borderDash: [2, 3],
            });
          }

          return {
            type: "line",
            data: { labels, datasets },
            options: {
              responsive: true,
              maintainAspectRatio: false,
              interaction: { mode: "index", intersect: false },
              plugins: {
                legend: { position: "bottom" },
                tooltip: { callbacks: { label: (ctx) => `${ctx.dataset.label}: ${gbp(ctx.parsed.y)}` } },
              },
              scales: {
                x: { ticks: { maxRotation: 0, autoSkip: true, maxTicksLimit: 10 }, grid: { display: false } },
                y: { title: { display: true, text: "LHS: Funding / Exposure" }, ticks: { callback: (v) => gbp(Number(v)) } },
                y1: {
                  position: "right",
                  title: { display: true, text: "RHS: Cumulative Profit / Interest" },
                  grid: { drawOnChartArea: false },
                  ticks: { callback: (v) => gbp(Number(v)) },
                },
              },
            },
          };
        }, [monthly, showCumInterestOnChart1]);

        /***************
         * Chart 2 config (UPDATED: add Total line on LHS)
         ***************/
       /***************
 * Chart 2 config (UPDATED per request)
 * - Removed: Total Net Cashflow line
 * - Removed: Interest Paid bars
 * - Added: Cumulative Rebates line on RHS
 ***************/
const chart2Config = useMemo(() => {
  const labels = monthly.map((r) => toMM(r.month));

  const cust = [];
  const rebates = [];
  const mfg = [];
  const debt = [];
  const cumRebates = [];

  for (let i = 0; i < monthly.length; i++) {
    const cur = monthly[i];
    const prev = i === 0 ? null : monthly[i - 1];

    const dCust = cur.cumCustomerIn - (prev ? prev.cumCustomerIn : 0);
    const dReb = cur.cumRebatesIn - (prev ? prev.cumRebatesIn : 0);
    const dMfgOut = cur.cumMfgOut - (prev ? prev.cumMfgOut : 0);

    cust.push(dCust);
    rebates.push(dReb);
    mfg.push(-dMfgOut);

    debt.push(cur.debtEOM);
    cumRebates.push(cur.cumRebatesIn); // cumulative (not monthly delta)
  }

  return {
    type: "bar",
    data: {
      labels,
      datasets: [
        { type: "bar", label: "Customer Receipts — LHS", data: cust, stack: "cashflow", borderWidth: 0 },
        { type: "bar", label: "Rebates — LHS", data: rebates, stack: "cashflow", borderWidth: 0 },
        { type: "bar", label: "Manufacturer Deposits — LHS", data: mfg, stack: "cashflow", borderWidth: 0 },

        // NEW: cumulative rebates line on RHS
        {
          type: "line",
          label: "Cumulative Rebates — RHS",
          data: cumRebates,
          yAxisID: "y1",
          tension: 0.25,
          borderWidth: 2,
          pointRadius: 0,
          borderDash: [4, 3],
        },

        // existing RHS line
        { type: "line", label: "Debt (EOM) — RHS", data: debt, yAxisID: "y1", tension: 0.25, borderWidth: 2, pointRadius: 0 },
      ],
    },
    options: {
      responsive: true,
      maintainAspectRatio: false,
      interaction: { mode: "index", intersect: false },
      plugins: {
        legend: { position: "bottom" },
        tooltip: { callbacks: { label: (ctx) => `${ctx.dataset.label}: ${gbp(ctx.parsed.y)}` } },
      },
      scales: {
        x: { stacked: true, ticks: { maxRotation: 0, autoSkip: true, maxTicksLimit: 10 }, grid: { display: false } },
        y: { stacked: true, title: { display: true, text: "LHS: Monthly Cashflow" }, ticks: { callback: (v) => gbp(Number(v)) } },
        y1: {
          position: "right",
          title: { display: true, text: "RHS: Debt Outstanding / Cumulative Rebates" },
          grid: { drawOnChartArea: false },
          ticks: { callback: (v) => gbp(Number(v)) },
        },
      },
    },
  };
}, [monthly]);


        return (
          <div className="page">
            <div className="row">
              <div>
                <h1>Deal Cashflow Model (single HTML file + scenarios)</h1>
                <div className="small">
                  Sale Month is a per-car slider (Mar–Sep 2026). Late Months is a per-car slider (0–3) applied to <b>D2, D3, and D4</b> customer payments.
                  Customer due dates are always 1 month ahead of each manufacturer deposit month. All month-based events occur on the <b>15th</b>.
                  Interest accrues daily on <b>ACT/365F</b> and is paid month-end.
                </div>
              </div>

              <div className="controls">
                <label className="small">
                  Scenario
                  <select value={selectedScenario} onChange={(e) => setSelectedScenario(e.target.value)} style={{ minWidth: 150 }}>
                    <option>Scenario 1</option>
                    <option>Scenario 2</option>
                  </select>
                </label>

                <div style={{ display: "flex", gap: 8, alignItems: "flex-end", flexWrap: "wrap" }}>
                  <button onClick={onApplyScenario} title="Overwrite car sliders with the selected scenario defaults">
                    Apply Scenario
                  </button>
                  <button
                    onClick={onResetToAppliedScenario}
                    disabled={!lastAppliedScenario}
                    title="Revert car sliders back to the last applied scenario defaults"
                  >
                    Reset to Applied Scenario
                  </button>
                </div>

                <label className="small">
                  # Cars
                  <input
                    type="number"
                    min="1"
                    value={deal.numCars}
                    onChange={(e) => applyDealPatch({ numCars: Math.max(1, Number(e.target.value || 1)) })}
                    style={{ width: 110 }}
                  />
                </label>

                <label className="small">
                  Build months
                  <input
                    type="number"
                    min="1"
                    value={deal.buildMonths}
                    onChange={(e) => applyDealPatch({ buildMonths: Math.max(1, Number(e.target.value || 1)) })}
                    style={{ width: 130 }}
                  />
                </label>

                <label className="small">
                  Debt rate (annual)
                  <input
                    type="number"
                    step="0.001"
                    value={deal.annualRate}
                    onChange={(e) => applyDealPatch({ annualRate: Math.max(0, Number(e.target.value || 0)) })}
                    style={{ width: 150 }}
                  />
                </label>

                <label className="small">
                  Start month
                  <MonthInput value={deal.startMonth} onChange={(v) => applyDealPatch({ startMonth: v })} min="2026-01" />
                </label>
              </div>
            </div>

            {/* KPI panel */}
            <div className="cardRow">
              <div className="card">
                <div className="small">Peak net exposure (unfinanced)</div>
                <div className="value">{gbp(kpis.peakNetExposure.value)}</div>
                <div className="small">Month: {kpis.peakNetExposure.month}</div>
              </div>

              <div className="card">
                <div className="small">Peak debt outstanding (EOM)</div>
                <div className="value">{gbp(kpis.peakDebt.value)}</div>
                <div className="small">Month: {kpis.peakDebt.month}</div>
              </div>

              <div className="card">
                <div className="small">Total rebates received (gross profit)</div>
                <div className="value">{gbp(kpis.totalRebates)}</div>
                <div className="small">Should equal £0.5m × cars if all cars complete</div>
              </div>

              <div className="card">
                <div className="small">Total interest paid</div>
                <div className="value">{gbp(kpis.totalInterestPaid)}</div>
                <div className="small">ACT/365F, paid month-end</div>
              </div>

              <div className="card">
                <div className="small">Interest drag (interest / rebates)</div>
                <div className="value">{pct(kpis.interestAsPctOfRebates)}</div>
                <div className="small">Informational</div>
              </div>

              <div className="card">
                <div className="small">Debt cleared month</div>
                <div className="value">{kpis.debtClearedMonth || "—"}</div>
                <div className="small">First month EOM debt returns to £0</div>
              </div>
            </div>

            {/* 2026 summary table under KPIs */}
            <div className="section">
              <div className="sectionTitle">Feb–Dec 2026 Summary (Monthly Cashflow + Exposure Roll-Forward)</div>
              <div className="tableWrap">
                <table>
                  <thead>
                    <tr>
                      <th className="rowLabelHead">Metric</th>
                      {summary2026.months.map((m) => (
                        <th key={m} className="mono right">{m}</th>
                      ))}
                    </tr>
                  </thead>
                  <tbody>
                    <tr>
                      <td className="rowLabel"><b>Cars sold (#)</b></td>
                      {summary2026.months.map((m) => (
                        <td key={m} className="mono right">{summary2026.carsSold[m]}</td>
                      ))}
                    </tr>

                    {/* UPDATED: split customer receipts into D1 and D2 */}
                    <tr className="rowGood">
                      <td className="rowLabel"><b>Deposits collected — D1 (customers, £)</b></td>
                      {summary2026.months.map((m) => (
                        <td key={m} className="mono right">{gbp(summary2026.depositsCollectedD1[m])}</td>
                      ))}
                    </tr>

                    <tr className="rowGood">
                      <td className="rowLabel"><b>Deposits collected — D2 (customers, £)</b></td>
                      {summary2026.months.map((m) => (
                        <td key={m} className="mono right">{gbp(summary2026.depositsCollectedD2[m])}</td>
                      ))}
                    </tr>

                    <tr className="rowBad">
                      <td className="rowLabel"><b>Deposits made to GMA (manufacturer, £)</b></td>
                      {summary2026.months.map((m) => (
                        <td key={m} className="mono right">{gbp(summary2026.depositsMade[m])}</td>
                      ))}
                    </tr>

                    <tr className="rowGood">
                      <td className="rowLabel"><b>Rebates collected (manufacturer, £)</b></td>
                      {summary2026.months.map((m) => (
                        <td key={m} className="mono right">{gbp(summary2026.rebatesCollected[m])}</td>
                      ))}
                    </tr>

                    <tr className="sumBlock">
                      <td className="rowLabel"><b>Net cashflow this month (£)</b></td>
                      {summary2026.months.map((m) => (
                        <td key={m} className="mono right">{gbp(summary2026.netCashflow[m])}</td>
                      ))}
                    </tr>

                    <tr className="sumBlock">
                      <td className="rowLabel"><b>Beginning exposure (£)</b></td>
                      {summary2026.months.map((m) => (
                        <td key={m} className="mono right">{gbp(summary2026.beginningExposure[m])}</td>
                      ))}
                    </tr>

                    <tr className="sumBlock sumBlue">
                      <td className="rowLabel"><b>Ending exposure (£)</b></td>
                      {summary2026.months.map((m) => (
                        <td key={m} className="mono right">{gbp(summary2026.endingExposure[m])}</td>
                      ))}
                    </tr>
                  </tbody>
                </table>
              </div>

              <div className="hint">
                Sign convention: Deposits collected and rebates are positive. Deposits made to GMA are negative. Net cashflow = (customer deposits + rebates + manufacturer deposits). Exposure is shown as positive when you are out cash, with Ending exposure = Beginning exposure − Net cashflow.
              </div>
            </div>

            {/* Charts under KPIs + 2026 table */}
            <div className="chartGrid">
              <div className="chartCard">
                <div className="chartHeader">
                  <div>
                    <div className="chartTitle">Chart 1: Exposure, Debt, and Cumulative Profit</div>
                    <div className="small">Legend tags indicate which axis each series uses (LHS vs RHS).</div>
                  </div>
                  <div className="chartTools">
                    <label className="toggleRow small" title="Show cumulative interest on Chart 1">
                      <input
                        type="checkbox"
                        checked={showCumInterestOnChart1}
                        onChange={(e) => setShowCumInterestOnChart1(e.target.checked)}
                      />
                      Show cumulative interest
                    </label>
                  </div>
                </div>
                <div className="chartCanvasWrap">
                  <ChartCanvas config={chart1Config} ariaLabel="Exposure, debt, cumulative rebates over time" />
                </div>
                <div className="hint">
                  Net Exposure (Unfinanced) = cumulative manufacturer deposits − (cumulative customer receipts + cumulative rebates).
                </div>
              </div>

              <div className="chartCard">
                <div className="chartHeader">
                  <div>
                    <div className="chartTitle">Chart 2: Monthly Cashflow Bridge (Stacked) + Debt Overlay</div>
                    <div className="small">Bars (LHS) show monthly inflows/outflows; lines (RHS) show end-of-month debt and cumulative rebates.</div>
                  </div>
                </div>
                <div className="chartCanvasWrap">
                  <ChartCanvas config={chart2Config} ariaLabel="Monthly cashflows with total line and debt overlay" />
                </div>
                <div className="hint">
  Positive bars are receipts (customers + rebates). Negative bars are payments (manufacturer deposits). RHS overlays show debt (EOM) and cumulative rebates.
</div>

              </div>
            </div>

            {/* Per-car schedule (simplified inputs) */}
            <div className="section">
              <div className="row">
                <div className="sectionTitle">Per-car schedule (simplified inputs)</div>
                <div className="badgeRow">
                  <span className="badge">Sale Month slider range: Mar–Sep 2026</span>
                  <span className="badge">Late Months slider range: 0–3 (applies to D2/D3/D4)</span>
                  <span className="badge">Customer Due Lead: {1} month ahead</span>
                  <span className="badge">Customer D2 Due Month (all cars): {dueD2}</span>
                  <span className="badge">MFG D1: 2026-02-01</span>
                  <span className="badge">MFG D2: 2026-07-15</span>
                </div>
              </div>

              <div className="tableWrap" style={{ marginTop: 10 }}>
                <table>
                  <thead>
                    <tr>
                      <th>Car</th>
                      <th>Sale Month (slider)</th>
                      <th>Late Months (slider)</th>
                      <th>Prod Start Month</th>
                      <th>Delivery Month</th>
                      <th>Due Months (D2 / D3 / D4)</th>
                      <th>Paid Months (D2 / D3 / D4)</th>
                    </tr>
                  </thead>
                  <tbody>
                    {cars.map((c) => {
                      const { dueD2, dueD3, dueD4, deliveryMonth } = computeDueMonths(deal, c.prodStartMonth);
                      const paidD2 = paidFromDueAndLate(dueD2, c.lateMonths);
                      const paidD3 = paidFromDueAndLate(dueD3, c.lateMonths);
                      const paidD4 = paidFromDueAndLate(dueD4, c.lateMonths);

                      return (
                        <tr key={c.id}>
                          <td className="mono">{c.id}</td>

                          <td>
                            <div className="sliderWrap">
                              <div className="sliderRow">
                                <input
                                  type="range"
                                  min="0"
                                  max={String(SALE_MONTHS.length - 1)}
                                  step="1"
                                  value={saleIndexFromMonth(c.saleMonth)}
                                  onChange={(e) => updateCar(c.id, { saleMonth: saleMonthFromIndex(e.target.value) })}
                                />
                                <span className="pill"><b>{c.saleMonth}</b></span>
                              </div>
                              <div className="mini tight">
                                Customer D1 (£1m) received on <b>{c.saleMonth}-15</b>.
                              </div>
                            </div>
                          </td>

                          <td>
                            <div className="sliderWrap">
                              <div className="sliderRow">
                                <input
                                  type="range"
                                  min="0"
                                  max="3"
                                  step="1"
                                  value={c.lateMonths}
                                  onChange={(e) => updateCar(c.id, { lateMonths: Number(e.target.value) })}
                                />
                                <span className="pill"><b>{c.lateMonths}</b> mo</span>
                              </div>
                              <div className="mini tight">
                                Customer D2/D3/D4 paid month = due month + late months.
                              </div>
                            </div>
                          </td>

                          <td>
                            <MonthInput value={c.prodStartMonth} onChange={(v) => updateCar(c.id, { prodStartMonth: v })} />
                            <div className="small tight">D3 due at start (15th); P3 rebate +14 days.</div>
                          </td>

                          <td>
                            <div style={{ fontWeight: 600 }}>{deliveryMonth}</div>
                            <div className="small tight">Delivery = start + {deal.buildMonths}m (15th); P4 rebate +14 days.</div>
                          </td>

                          <td className="mono">
                            <div>D2 due: {dueD2}</div>
                            <div>D3 due: {dueD3}</div>
                            <div>D4 due: {dueD4}</div>
                          </td>

                          <td className="mono">
                            <div>D2 paid: {paidD2}</div>
                            <div>D3 paid: {paidD3}</div>
                            <div>D4 paid: {paidD4}</div>
                          </td>
                        </tr>
                      );
                    })}
                  </tbody>
                </table>
              </div>
            </div>

            {/* Monthly outputs */}
            <div className="section">
              <div className="sectionTitle">Monthly outputs (end-of-month)</div>
              <div className="tableWrap">
                <table>
                  <thead>
                    <tr>
                      <th>Month</th>
                      <th className="right">Cash (EOM)</th>
                      <th className="right">Debt (EOM)</th>
                      <th className="right">Net exposure (unfinanced)</th>
                      <th className="right">Cum customer receipts</th>
                      <th className="right">Cum mfg deposits</th>
                      <th className="right">Cum rebates</th>
                      <th className="right">Cum interest paid</th>
                    </tr>
                  </thead>
                  <tbody>
                    {monthly.map((r) => (
                      <tr key={r.month}>
                        <td className="mono">{r.month}</td>
                        <td className="right">{gbp(r.cashEOM)}</td>
                        <td className="right">{gbp(r.debtEOM)}</td>
                        <td className="right">{gbp(r.netExposureUnfinanced)}</td>
                        <td className="right">{gbp(r.cumCustomerIn)}</td>
                        <td className="right">{gbp(r.cumMfgOut)}</td>
                        <td className="right">{gbp(r.cumRebatesIn)}</td>
                        <td className="right">{gbp(r.cumInterestPaid)}</td>
                      </tr>
                    ))}
                  </tbody>
                </table>
              </div>
              <div className="hint">
                Net exposure (unfinanced) = cumulative manufacturer deposits − (cumulative customer receipts + cumulative rebates). This metric is independent of the debt draws/sweeps mechanics.
              </div>
            </div>

            {/* Audit ledger */}
            <div className="section">
              <details>
                <summary className="sectionTitle">Audit ledger (chronological)</summary>
                <div className="tableWrap" style={{ marginTop: 10 }}>
                  <table>
                    <thead>
                      <tr>
                        <th>Date</th>
                        <th>Type</th>
                        <th>Label</th>
                        <th className="right">Amount</th>
                        <th className="right">Cash after</th>
                        <th className="right">Debt after</th>
                      </tr>
                    </thead>
                    <tbody>
                      {ledger.map((r, idx) => (
                        <tr key={idx}>
                          <td className="mono">{r.dateISO}</td>
                          <td className="mono">{r.type}</td>
                          <td>{r.label}</td>
                          <td className="right">{gbp(r.amount)}</td>
                          <td className="right">{gbp(r.cashAfter)}</td>
                          <td className="right">{gbp(r.debtAfter)}</td>
                        </tr>
                      ))}
                    </tbody>
                  </table>
                </div>
              </details>
            </div>

            <div className="section small">
              Hosting note: commit this as <span className="mono">index.html</span> in a GitHub repo and enable GitHub Pages. It will run as-is (no build step).
            </div>
          </div>
        );
      }

      const root = ReactDOM.createRoot(document.getElementById("root"));
      root.render(<App />);
    </script>
  </body>
</html>
