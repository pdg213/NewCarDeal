<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Deal Cashflow Model (Single-File + Scenarios + Charts + Sliders)</title>

    <!-- React + ReactDOM (UMD) -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>

    <!-- Babel (JSX in a single HTML file) -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <!-- Chart.js (UMD) -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>

    <style>
      :root {
        --border: #ddd;
        --border2: #eee;
        --text: #111;
        --muted: #555;
        --bg: #fff;

        /* Styling for summary table rows */
        --pos: #0b7a0b;      /* green */
        --neg: #b00020;      /* red */
        --profit: #00c853;   /* bright green line */
      }

      body {
        margin: 0;
        background: #fafafa;
        color: var(--text);
        font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      }
      .page {
        padding: 18px;
        max-width: 1500px;
        margin: 0 auto;
      }

      h1 {
        margin: 0;
        font-size: 18px;
      }
      .small {
        color: var(--muted);
        font-size: 12px;
      }
      .row {
        display: flex;
        gap: 12px;
        flex-wrap: wrap;
        align-items: center;
      }
      .controls {
        margin-left: auto;
        display: flex;
        gap: 10px;
        flex-wrap: wrap;
        align-items: center;
      }
      label {
        display: inline-flex;
        flex-direction: column;
        gap: 4px;
      }
      input[type="number"],
      input[type="month"],
      select {
        padding: 4px 6px;
        border: 1px solid var(--border);
        border-radius: 8px;
        background: var(--bg);
      }
      input[type="range"] {
        width: 220px;
      }
      input[type="checkbox"] {
        width: 16px;
        height: 16px;
      }

      .section {
        margin-top: 18px;
      }
      .sectionTitle {
        font-weight: 700;
        margin-bottom: 8px;
      }

      .badgeRow {
        display: flex;
        gap: 8px;
        flex-wrap: wrap;
        align-items: center;
      }
      .badge {
        display: inline-block;
        padding: 2px 8px;
        border-radius: 999px;
        border: 1px solid var(--border);
        font-size: 12px;
        color: #333;
        background: var(--bg);
      }

      /* KPI */
      .kpiGrid {
        display: grid;
        grid-template-columns: 1fr;
        gap: 12px;
        margin-top: 14px;
      }
      @media (min-width: 1100px) {
        .kpiGrid {
          grid-template-columns: 1fr 1fr;
        }
      }
      .kpiPanel {
        border: 1px solid var(--border);
        border-radius: 12px;
        padding: 12px;
        background: var(--bg);
      }
      .kpiHeader {
        display: flex;
        align-items: baseline;
        justify-content: space-between;
        gap: 10px;
        flex-wrap: wrap;
        margin-bottom: 8px;
      }
      .kpiTitle {
        font-weight: 700;
      }
      .cardRow {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
        gap: 10px;
      }
      .card {
        border: 1px solid var(--border);
        border-radius: 12px;
        padding: 10px;
        background: #fff;
      }
      .card .value {
        font-size: 18px;
        margin-top: 6px;
      }

      /* Tables */
      .tableWrap {
        overflow-x: auto;
        border: 1px solid var(--border);
        border-radius: 12px;
        background: var(--bg);
      }
      table {
        width: 100%;
        border-collapse: collapse;
      }
      th {
        text-align: left;
        border-bottom: 1px solid var(--border);
        padding: 8px 6px;
        font-size: 12px;
        color: #444;
        background: #fcfcfc;
        white-space: nowrap;
      }
      td {
        border-bottom: 1px solid var(--border2);
        padding: 8px 6px;
        vertical-align: top;
        font-size: 13px;
      }
      tr:last-child td {
        border-bottom: none;
      }
      .right { text-align: right; }
      .mono {
        font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      }

      /* Summary row coloring */
      .rowPos td { color: var(--pos); }
      .rowNeg td { color: var(--neg); }
      .rowNeutral td { color: var(--text); }
      .rowTitle {
        font-weight: 700;
        color: var(--text) !important;
      }

      /* Charts */
      .chartGrid {
        display: grid;
        grid-template-columns: 1fr;
        gap: 12px;
        margin-top: 12px;
      }
      @media (min-width: 1100px) {
        .chartGrid {
          grid-template-columns: 1fr 1fr;
        }
      }
      .chartCard {
        border: 1px solid var(--border);
        border-radius: 12px;
        padding: 12px;
        background: var(--bg);
      }
      .chartHeader {
        display: flex;
        align-items: flex-end;
        justify-content: space-between;
        gap: 12px;
        flex-wrap: wrap;
        margin-bottom: 8px;
      }
      .chartTitle {
        font-weight: 700;
      }
      .chartTools {
        display: flex;
        gap: 10px;
        align-items: center;
        flex-wrap: wrap;
      }
      .chartCanvasWrap {
        position: relative;
        height: 360px;
      }
      .hint {
        color: var(--muted);
        font-size: 12px;
        margin-top: 8px;
        line-height: 1.35;
      }

      /* Sliders */
      .sliderWrap {
        display: flex;
        flex-direction: column;
        gap: 6px;
        min-width: 280px;
      }
      .sliderRow {
        display: flex;
        gap: 10px;
        align-items: center;
        flex-wrap: wrap;
      }
      .pill {
        display: inline-block;
        padding: 2px 8px;
        border-radius: 999px;
        border: 1px solid var(--border);
        background: #fff;
        font-size: 12px;
      }
      .sliderValue { font-weight: 700; }
      .mini { font-size: 11px; color: var(--muted); line-height: 1.25; }

      /* Side-by-side Feb-Dec summary */
      .summaryGrid {
        display: grid;
        grid-template-columns: 1fr;
        gap: 12px;
      }
      @media (min-width: 1100px) {
        .summaryGrid {
          grid-template-columns: 1fr 1fr;
        }
      }

      details summary { cursor: pointer; }
    </style>
  </head>

  <body>
    <div id="root"></div>

    <script type="text/babel">
      const { useMemo, useState, useEffect, useRef } = React;

      /***************
       * Utilities
       ***************/
      const GBP = 1_000_000;

      function pad2(n) { return String(n).padStart(2, "0"); }

      function gbp(n) {
        const sign = n < 0 ? "-" : "";
        const abs = Math.abs(n);
        return sign + "£" + abs.toLocaleString(undefined, { maximumFractionDigits: 0 });
      }

      function pct(n) { return (n * 100).toFixed(1) + "%"; }

      // MonthStr is "YYYY-MM"
      function monthToYMD(month) {
        const [yStr, mStr] = month.split("-");
        return { y: Number(yStr), m: Number(mStr) }; // m: 1-12
      }

      function fmtMonth(y, m) { return `${y}-${pad2(m)}`; }

      function addMonths(month, delta) {
        const { y, m } = monthToYMD(month);
        let total = y * 12 + (m - 1) + delta;
        const ny = Math.floor(total / 12);
        const nm0 = total % 12;
        return fmtMonth(ny, nm0 + 1);
      }

      function dateUTC(y, m, d) { return new Date(Date.UTC(y, m - 1, d)); }

      function monthDate15(month) {
        const { y, m } = monthToYMD(month);
        return dateUTC(y, m, 15);
      }

      function addDaysUTC(d, days) {
        const nd = new Date(d.getTime());
        nd.setUTCDate(nd.getUTCDate() + days);
        return nd;
      }

      function toISODate(d) {
        const y = d.getUTCFullYear();
        const m = pad2(d.getUTCMonth() + 1);
        const day = pad2(d.getUTCDate());
        return `${y}-${m}-${day}`;
      }

      function isMonthEndUTC(d) {
        const next = addDaysUTC(d, 1);
        return next.getUTCMonth() !== d.getUTCMonth();
      }

      function endOfMonthUTC(month) {
        const { y, m } = monthToYMD(month);
        const firstNext = m === 12 ? dateUTC(y + 1, 1, 1) : dateUTC(y, m + 1, 1);
        return addDaysUTC(firstNext, -1);
      }

      // Slider mapping: March..September 2026
      const SALE_MONTHS = ["2026-03","2026-04","2026-05","2026-06","2026-07","2026-08","2026-09"];
      function saleIndexFromMonth(month) {
        const idx = SALE_MONTHS.indexOf(month);
        return idx >= 0 ? idx : 0;
      }
      function saleMonthFromIndex(i) {
        const idx = Math.min(Math.max(Number(i), 0), SALE_MONTHS.length - 1);
        return SALE_MONTHS[idx];
      }

      /***************
       * Model logic
       ***************/
      function typePriority(t) {
        // 1) Customer receipts 2) Manufacturer deposits 3) Rebates 4) Sweep/draw 5) Month-end interest
        switch (t) {
          case "CUST_IN": return 1;
          case "MFG_OUT": return 2;
          case "REBATE_IN": return 3;
          case "DEBT_REPAY": return 4;
          case "DEBT_DRAW": return 4;
          case "INT_PAID": return 5;
          default: return 99;
        }
      }

      function computeDueMonths(deal, prodStartMonth) {
        // Customer due lead is fixed at 1 month ahead
        const d2DepositMonth = "2026-07"; // manufacturer D2 month
        const dueD2 = addMonths(d2DepositMonth, -1); // June 2026
        const dueD3 = addMonths(prodStartMonth, -1);
        const deliveryMonth = addMonths(prodStartMonth, deal.buildMonths);
        const dueD4 = addMonths(deliveryMonth, -1);
        return { dueD2, dueD3, dueD4, deliveryMonth };
      }

      function paidFromDueAndLate(dueMonth, lateMonths) {
        return addMonths(dueMonth, lateMonths);
      }

      // scenarioLateAdd: additional lateness applied to D2/D3/D4 customer payments
      function buildCashflow(deal, cars, scenarioLateAdd) {
        const numCars = cars.length;

        // per car deposits
        const D1 = 1 * GBP;
        const D2 = 1 * GBP;
        const D3 = 1 * GBP;
        const D4 = 2 * GBP;

        // rebates: 10% of each deposit; P4 = 10% of D4 (0.2m)
        const R1 = 0.1 * GBP;
        const R2 = 0.1 * GBP;
        const R3 = 0.1 * GBP;
        const R4 = 0.2 * GBP;

        const raw = [];

        // Fixed manufacturer deposits (portfolio-level)
        raw.push({ date: dateUTC(2026, 2, 1), type: "MFG_OUT", label: "Manufacturer D1 (all cars)", amount: -(D1 * numCars) });
        raw.push({ date: dateUTC(2026, 7, 15), type: "MFG_OUT", label: "Manufacturer D2 (all cars)", amount: -(D2 * numCars) });

        // Fixed rebates (portfolio-level)
        raw.push({ date: dateUTC(2026, 5, 15), type: "REBATE_IN", label: "Rebate P1 = 10% of D1 (all cars)", amount: +(R1 * numCars) });
        raw.push({ date: dateUTC(2026, 8, 1), type: "REBATE_IN", label: "Rebate P2 = 10% of D2 (all cars)", amount: +(R2 * numCars) });

        // Per-car events
        for (const c of cars) {
          // Customer D1 on sale date (15th)
          raw.push({ date: monthDate15(c.saleMonth), type: "CUST_IN", tranche: "D1", label: `Car ${c.id}: Customer D1 receipt`, amount: +D1 });

          const { dueD2, dueD3, dueD4 } = computeDueMonths(deal, c.prodStartMonth);

          // Paid months are due month + (car late + scenario add), applies to D2/D3/D4
          const totalLate = Math.max(0, Math.min(12, Number(c.lateMonths) + Number(scenarioLateAdd || 0)));

          const paidD2Month = paidFromDueAndLate(dueD2, totalLate);
          const paidD3Month = paidFromDueAndLate(dueD3, totalLate);
          const paidD4Month = paidFromDueAndLate(dueD4, totalLate);

          raw.push({ date: monthDate15(paidD2Month), type: "CUST_IN", tranche: "D2", label: `Car ${c.id}: Customer D2 receipt (late ${totalLate}m)`, amount: +D2 });
          raw.push({ date: monthDate15(paidD3Month), type: "CUST_IN", tranche: "D3", label: `Car ${c.id}: Customer D3 receipt (late ${totalLate}m)`, amount: +D3 });
          raw.push({ date: monthDate15(paidD4Month), type: "CUST_IN", tranche: "D4", label: `Car ${c.id}: Customer D4 receipt (late ${totalLate}m)`, amount: +D4 });

          const prodStart = monthDate15(c.prodStartMonth);
          const deliveryMonth = addMonths(c.prodStartMonth, deal.buildMonths);
          const deliveryDate = monthDate15(deliveryMonth);

          // Manufacturer D3 / D4
          raw.push({ date: prodStart, type: "MFG_OUT", label: `Car ${c.id}: Manufacturer D3`, amount: -D3 });
          raw.push({ date: deliveryDate, type: "MFG_OUT", label: `Car ${c.id}: Manufacturer D4 (delivery)`, amount: -D4 });

          // Rebates P3/P4 = +14 days
          raw.push({ date: addDaysUTC(prodStart, 14), type: "REBATE_IN", label: `Car ${c.id}: Rebate P3 = 10% of D3`, amount: +R3 });
          raw.push({ date: addDaysUTC(deliveryDate, 14), type: "REBATE_IN", label: `Car ${c.id}: Rebate P4 = 10% of D4`, amount: +R4 });
        }

        // Determine sim window: start at deal.startMonth, end at max event month + 2
        const { y: sy, m: sm } = monthToYMD(deal.startMonth);
        const minDate = dateUTC(sy, sm, 1);

        let maxEventDate = minDate;
        for (const e of raw) if (e.date > maxEventDate) maxEventDate = e.date;

        const maxMonth = fmtMonth(maxEventDate.getUTCFullYear(), maxEventDate.getUTCMonth() + 1);
        const simEndMonth = addMonths(maxMonth, 2);
        const simEndDate = endOfMonthUTC(simEndMonth);

        // Group events by date
        const byDate = new Map();
        for (const e of raw) {
          const key = toISODate(e.date);
          if (!byDate.has(key)) byDate.set(key, []);
          byDate.get(key).push(e);
        }
        for (const [k, arr] of byDate.entries()) {
          arr.sort((a, b) => typePriority(a.type) - typePriority(b.type));
          byDate.set(k, arr);
        }

        // State
        let cash = 0;
        let debt = 0;
        let accruedInterestThisMonth = 0;

        let cumCustomerIn = 0;
        let cumCustD1 = 0;
        let cumCustD2 = 0;
        let cumCustD3 = 0;
        let cumCustD4 = 0;

        let cumMfgOut = 0;
        let cumRebatesIn = 0;
        let cumInterestPaid = 0;

        const ledger = [];
        const monthly = [];

        function record(dateISO, type, label, amount) {
          ledger.push({ dateISO, type, label, amount, cashAfter: cash, debtAfter: debt });
        }

        function drawIfNeeded(dateISO, context) {
          if (cash < 0) {
            const draw = -cash;
            debt += draw;
            cash = 0;
            record(dateISO, "DEBT_DRAW", `Debt draw (to fund ${context})`, +draw);
          }
        }

        function sweep(dateISO) {
          if (cash > 0 && debt > 0) {
            const repay = Math.min(cash, debt);
            cash -= repay;
            debt -= repay;
            record(dateISO, "DEBT_REPAY", "Debt repay (cash sweep)", -repay);
          }
        }

        // Iterate day-by-day UTC
        let d = new Date(minDate.getTime());
        while (d <= simEndDate) {
          const dateISO = toISODate(d);
          const todays = byDate.get(dateISO) || [];

          for (const e of todays) {
            cash += e.amount;

            if (e.type === "CUST_IN") {
              cumCustomerIn += e.amount;
              if (e.tranche === "D1") cumCustD1 += e.amount;
              if (e.tranche === "D2") cumCustD2 += e.amount;
              if (e.tranche === "D3") cumCustD3 += e.amount;
              if (e.tranche === "D4") cumCustD4 += e.amount;
            }
            if (e.type === "MFG_OUT") cumMfgOut += -e.amount; // store positive outflow
            if (e.type === "REBATE_IN") cumRebatesIn += e.amount;

            record(dateISO, e.type, e.label, e.amount);
            drawIfNeeded(dateISO, e.label);
          }

          // sweep same day
          sweep(dateISO);

          // daily interest accrual on end-of-day debt (ACT/365F)
          const dailyRate = deal.annualRate / 365.0;
          accruedInterestThisMonth += debt * dailyRate;

          // pay interest at month-end
          if (isMonthEndUTC(d)) {
            if (accruedInterestThisMonth > 0) {
              const pay = accruedInterestThisMonth;
              cash -= pay;
              cumInterestPaid += pay;
              record(dateISO, "INT_PAID", "Interest paid (month-end, ACT/365F)", -pay);
              accruedInterestThisMonth = 0;
              drawIfNeeded(dateISO, "interest payment");
            }

            const monthStr = fmtMonth(d.getUTCFullYear(), d.getUTCMonth() + 1);
            const netExposureUnfinanced = cumMfgOut - (cumCustomerIn + cumRebatesIn);

            monthly.push({
              month: monthStr,
              cashEOM: cash,
              debtEOM: debt,
              cumCustomerIn,
              cumCustD1,
              cumCustD2,
              cumCustD3,
              cumCustD4,
              cumMfgOut,
              cumRebatesIn,
              cumInterestPaid,
              netExposureUnfinanced,
            });
          }

          d = addDaysUTC(d, 1);
        }

        // KPIs
        let peakNet = { value: 0, month: monthly[0]?.month || deal.startMonth };
        let peakDebt = { value: 0, month: monthly[0]?.month || deal.startMonth };

        for (const r of monthly) {
          if (r.netExposureUnfinanced > peakNet.value) peakNet = { value: r.netExposureUnfinanced, month: r.month };
          if (r.debtEOM > peakDebt.value) peakDebt = { value: r.debtEOM, month: r.month };
        }

        const last = monthly[monthly.length - 1] || null;
        const totalRebates = last ? last.cumRebatesIn : 0;
        const totalInterestPaid = last ? last.cumInterestPaid : 0;

        let sawDebt = false;
        let debtClearedMonth = null;
        for (const r of monthly) {
          if (r.debtEOM > 0) sawDebt = true;
          if (sawDebt && r.debtEOM === 0) { debtClearedMonth = r.month; break; }
        }

        const profitAfterInterest = totalRebates - totalInterestPaid;
        const interestAsPctOfRebates = totalRebates > 0 ? totalInterestPaid / totalRebates : 0;
        const profitOverPeakExposure = peakNet.value > 0 ? totalRebates / peakNet.value : 0;

        const kpis = {
          peakNetExposure: peakNet,
          peakDebt: peakDebt,
          totalRebates,
          totalInterestPaid,
          profitAfterInterest,
          interestAsPctOfRebates,
          profitOverPeakExposure,
          debtClearedMonth,
        };

        return { ledger, monthly, kpis };
      }

      /***************
       * Chart helpers
       ***************/
      function ChartCanvas({ config, ariaLabel }) {
        const ref = useRef(null);
        const chartRef = useRef(null);

        useEffect(() => {
          if (!ref.current) return;

          if (chartRef.current) {
            chartRef.current.destroy();
            chartRef.current = null;
          }

          const ctx = ref.current.getContext("2d");
          chartRef.current = new Chart(ctx, config);

          return () => {
            if (chartRef.current) {
              chartRef.current.destroy();
              chartRef.current = null;
            }
          };
        }, [config]);

        return <canvas ref={ref} role="img" aria-label={ariaLabel}></canvas>;
      }

      function MonthInput({ value, onChange, min, max }) {
        return (
          <input
            type="month"
            value={value}
            min={min}
            max={max}
            onChange={(e) => onChange(e.target.value)}
          />
        );
      }

      function defaultProdStartForIndex(i) {
        if (i < 4) return "2027-10";
        if (i < 8) return "2027-11";
        return "2027-12";
      }

      function clampCars(target, existing) {
        const next = [];
        for (let i = 0; i < target; i++) {
          const id = i + 1;
          const prev = existing[i];
          if (prev) next.push({ ...prev, id });
          else next.push({ id, saleMonth: "2026-03", prodStartMonth: defaultProdStartForIndex(i), lateMonths: 0 });
        }
        return next;
      }

      /***************
       * Feb–Dec pivot builder (months as columns)
       ***************/
      function buildFebDecPivot(monthly, cars) {
        const monthMap = new Map();
        for (const r of monthly) monthMap.set(r.month, r);

        const months = [];
        let m = "2026-02";
        while (m <= "2026-12") { months.push(m); m = addMonths(m, 1); }

        const safe = (x) => (x == null ? 0 : x);

        // Cars sold (#) by month
        const soldByMonth = {};
        for (const c of cars) soldByMonth[c.saleMonth] = (soldByMonth[c.saleMonth] || 0) + 1;

        // Per-month components (monthly deltas)
        const flowByMonth = {};
        for (const mm of months) {
          const cur = monthMap.get(mm);
          const prev = monthMap.get(addMonths(mm, -1));

          const curD1 = safe(cur?.cumCustD1);
          const curD2 = safe(cur?.cumCustD2);
          const curMfg = safe(cur?.cumMfgOut);
          const curReb = safe(cur?.cumRebatesIn);

          const prevD1 = safe(prev?.cumCustD1);
          const prevD2 = safe(prev?.cumCustD2);
          const prevMfg = safe(prev?.cumMfgOut);
          const prevReb = safe(prev?.cumRebatesIn);

          const d1 = curD1 - prevD1;
          const d2 = curD2 - prevD2;
          const mfg = -(curMfg - prevMfg); // negative cashflow
          const reb = curReb - prevReb;
          const net = d1 + d2 + reb + mfg;

          const begExp = safe(prev?.netExposureUnfinanced);
          const endExp = safe(cur?.netExposureUnfinanced);

          flowByMonth[mm] = { d1, d2, mfg, reb, net, begExp, endExp };
        }

        const rows = [
          { label: "Cars sold (#)", kind: "int", tone: "neutral", values: months.map((mm) => soldByMonth[mm] || 0) },

          { label: "Deposits collected — D1 (customers, £)", kind: "gbp", tone: "pos", values: months.map((mm) => flowByMonth[mm].d1) },
          { label: "Deposits collected — D2 (customers, £)", kind: "gbp", tone: "pos", values: months.map((mm) => flowByMonth[mm].d2) },

          { label: "Deposits made to GMA (manufacturer, £)", kind: "gbp", tone: "neg", values: months.map((mm) => flowByMonth[mm].mfg) },
          { label: "Rebates collected (manufacturer, £)", kind: "gbp", tone: "pos", values: months.map((mm) => flowByMonth[mm].reb) },

          { label: "Net cashflow this month (£)", kind: "gbp", tone: "neutral", values: months.map((mm) => flowByMonth[mm].net) },
          { label: "Beginning exposure (£)", kind: "gbp", tone: "neutral", values: months.map((mm) => flowByMonth[mm].begExp) },
          { label: "Ending exposure (£)", kind: "gbp", tone: "neutral", values: months.map((mm) => flowByMonth[mm].endExp) },
        ];

        return { months, rows };
      }

      function App() {
        const [deal, setDeal] = useState({
          numCars: 12,
          buildMonths: 4,
          annualRate: 0.085,
          startMonth: "2026-01",
        });

        const [cars, setCars] = useState(() => clampCars(12, []));

        // Scenario B: additional lateness applied to D2/D3/D4
        const [scenarioBLateAdd, setScenarioBLateAdd] = useState(2);

        // Chart 2 scenario selection (A or B)
        const [chart2Scenario, setChart2Scenario] = useState("A");

        function applyDealPatch(patch) {
          const nextDeal = { ...deal, ...patch };
          setDeal(nextDeal);
          setCars((prev) => clampCars(nextDeal.numCars, prev));
        }

        function updateCar(id, patch) {
          setCars((prev) => prev.map((c) => (c.id === id ? { ...c, ...patch } : c)));
        }

        // Build scenario A and B results
        const scenarioA = useMemo(() => buildCashflow(deal, cars, 0), [deal, cars]);
        const scenarioB = useMemo(() => buildCashflow(deal, cars, scenarioBLateAdd), [deal, cars, scenarioBLateAdd]);

        // Build Feb-Dec pivots (months as columns)
        const pivotA = useMemo(() => buildFebDecPivot(scenarioA.monthly, cars), [scenarioA.monthly, cars]);
        const pivotB = useMemo(() => buildFebDecPivot(scenarioB.monthly, cars), [scenarioB.monthly, cars]);

        /***************
         * Chart 1: Exposure + Debt overlays (Scenario A vs B)
         * (No bright green profit line here.)
         ***************/
        const chart1Config = useMemo(() => {
          const labels = scenarioA.monthly.map((r) => r.month);

          const netA = scenarioA.monthly.map((r) => r.netExposureUnfinanced);
          const debtA = scenarioA.monthly.map((r) => r.debtEOM);

          const netB = scenarioB.monthly.map((r) => r.netExposureUnfinanced);
          const debtB = scenarioB.monthly.map((r) => r.debtEOM);

          return {
            type: "line",
            data: {
              labels,
              datasets: [
                { label: "Net Exposure (Unfinanced) — Scenario A (LHS)", data: netA, yAxisID: "y", tension: 0.25, borderWidth: 2, pointRadius: 0 },
                { label: "Debt Outstanding (EOM) — Scenario A (LHS)", data: debtA, yAxisID: "y", tension: 0.25, borderWidth: 2, pointRadius: 0, borderDash: [6,4] },

                { label: "Net Exposure (Unfinanced) — Scenario B (LHS)", data: netB, yAxisID: "y", tension: 0.25, borderWidth: 2, pointRadius: 0, borderDash: [2,3] },
                { label: "Debt Outstanding (EOM) — Scenario B (LHS)", data: debtB, yAxisID: "y", tension: 0.25, borderWidth: 2, pointRadius: 0, borderDash: [10,4] },
              ],
            },
            options: {
              responsive: true,
              maintainAspectRatio: false,
              interaction: { mode: "index", intersect: false },
              plugins: {
                legend: { position: "bottom" },
                tooltip: { callbacks: { label: (ctx) => `${ctx.dataset.label}: ${gbp(ctx.parsed.y)}` } },
              },
              scales: {
                x: { ticks: { maxRotation: 0, autoSkip: true, maxTicksLimit: 10 }, grid: { display: false } },
                y: { title: { display: true, text: "LHS: Exposure / Debt" }, ticks: { callback: (v) => gbp(Number(v)) } },
              },
            },
          };
        }, [scenarioA.monthly, scenarioB.monthly]);

        /***************
         * Chart 2: Monthly cashflow bars + Debt RHS + Cumulative Profit RHS2 (BRIGHT GREEN)
         * Uses selected scenario (A or B).
         ***************/
        const chart2Config = useMemo(() => {
          const s = chart2Scenario === "B" ? scenarioB : scenarioA;
          const labels = s.monthly.map((r) => r.month);

          const cust = [];
          const rebates = [];
          const mfg = [];
          const interest = [];
          const debt = [];
          const cumProfit = [];

          for (let i = 0; i < s.monthly.length; i++) {
            const cur = s.monthly[i];
            const prev = i === 0 ? null : s.monthly[i - 1];

            const dCust = cur.cumCustomerIn - (prev ? prev.cumCustomerIn : 0);
            const dReb = cur.cumRebatesIn - (prev ? prev.cumRebatesIn : 0);
            const dMfgOut = cur.cumMfgOut - (prev ? prev.cumMfgOut : 0);
            const dInt = cur.cumInterestPaid - (prev ? prev.cumInterestPaid : 0);

            cust.push(dCust);
            rebates.push(dReb);
            mfg.push(-dMfgOut);
            interest.push(-dInt);
            debt.push(cur.debtEOM);
            cumProfit.push(cur.cumRebatesIn);
          }

          return {
            type: "bar",
            data: {
              labels,
              datasets: [
                { type: "bar", label: `Customer Receipts — ${chart2Scenario} (LHS)`, data: cust, stack: "cashflow", borderWidth: 0 },
                { type: "bar", label: `Rebates — ${chart2Scenario} (LHS)`, data: rebates, stack: "cashflow", borderWidth: 0 },
                { type: "bar", label: `Manufacturer Deposits — ${chart2Scenario} (LHS)`, data: mfg, stack: "cashflow", borderWidth: 0 },
                { type: "bar", label: `Interest Paid — ${chart2Scenario} (LHS)`, data: interest, stack: "cashflow", borderWidth: 0 },

                { type: "line", label: `Debt (EOM) — ${chart2Scenario} (RHS)`, data: debt, yAxisID: "y1", tension: 0.25, borderWidth: 2, pointRadius: 0 },

                /* Requested: BRIGHT GREEN “light” for cumulative profit on RHS2 */
                { type: "line", label: `Cumulative Profit (Rebates) — ${chart2Scenario} (RHS2)`, data: cumProfit, yAxisID: "y2", tension: 0.25, borderWidth: 3, pointRadius: 0, borderColor: "#00C853" },
              ],
            },
            options: {
              responsive: true,
              maintainAspectRatio: false,
              interaction: { mode: "index", intersect: false },
              plugins: {
                legend: { position: "bottom" },
                tooltip: { callbacks: { label: (ctx) => `${ctx.dataset.label}: ${gbp(ctx.parsed.y)}` } },
              },
              scales: {
                x: { stacked: true, ticks: { maxRotation: 0, autoSkip: true, maxTicksLimit: 10 }, grid: { display: false } },

                y: { stacked: true, title: { display: true, text: "LHS: Monthly Cashflow" }, ticks: { callback: (v) => gbp(Number(v)) } },

                y1: {
                  position: "right",
                  title: { display: true, text: "RHS: Debt Outstanding" },
                  grid: { drawOnChartArea: false },
                  ticks: { callback: (v) => gbp(Number(v)) },
                },

                y2: {
                  position: "right",
                  offset: true,
                  title: { display: true, text: "RHS2: Cumulative Profit (Rebates)" },
                  grid: { drawOnChartArea: false },
                  ticks: { callback: (v) => gbp(Number(v)) },
                },
              },
            },
          };
        }, [scenarioA, scenarioB, chart2Scenario]);

        const d2DepositMonth = "2026-07";
        const dueD2 = addMonths(d2DepositMonth, -1);

        function renderPivotTable(title, pivot) {
          return (
            <div className="kpiPanel">
              <div className="kpiHeader">
                <div className="kpiTitle">{title}</div>
                <div className="small">Months are columns; rows are cashflow/exposure lines.</div>
              </div>
              <div className="tableWrap">
                <table>
                  <thead>
                    <tr>
                      <th>Metric</th>
                      {pivot.months.map((m) => (
                        <th key={m} className="right mono">{m}</th>
                      ))}
                    </tr>
                  </thead>
                  <tbody>
                    {pivot.rows.map((r) => {
                      const cls = r.tone === "pos" ? "rowPos" : r.tone === "neg" ? "rowNeg" : "rowNeutral";
                      return (
                        <tr key={r.label} className={cls}>
                          <td className="rowTitle">{r.label}</td>
                          {r.values.map((v, i) => (
                            <td key={i} className="right">
                              {r.kind === "int" ? String(v) : gbp(v)}
                            </td>
                          ))}
                        </tr>
                      );
                    })}
                  </tbody>
                </table>
              </div>

              <div className="small" style={{ marginTop: 8 }}>
                Sign convention: deposits collected and rebates are positive (green). Deposits made to GMA are negative (red).
                Net cashflow = (D1 + D2 + rebates + manufacturer deposits). Exposure is positive when you are out cash.
              </div>
            </div>
          );
        }

        function renderKpis(title, k) {
          return (
            <div className="kpiPanel">
              <div className="kpiHeader">
                <div className="kpiTitle">{title}</div>
                <div className="small">Audit-friendly KPIs based on full daily accrual + month-end interest.</div>
              </div>

              <div className="cardRow">
                <div className="card">
                  <div className="small">Peak net exposure (unfinanced)</div>
                  <div className="value">{gbp(k.peakNetExposure.value)}</div>
                  <div className="small">Month: {k.peakNetExposure.month}</div>
                </div>

                <div className="card">
                  <div className="small">Peak debt outstanding (EOM)</div>
                  <div className="value">{gbp(k.peakDebt.value)}</div>
                  <div className="small">Month: {k.peakDebt.month}</div>
                </div>

                <div className="card">
                  <div className="small">Total rebates received (gross profit)</div>
                  <div className="value">{gbp(k.totalRebates)}</div>
                  <div className="small">Should converge to £0.5m × cars if all complete</div>
                </div>

                <div className="card">
                  <div className="small">Total interest paid</div>
                  <div className="value">{gbp(k.totalInterestPaid)}</div>
                  <div className="small">ACT/365F, paid month-end</div>
                </div>

                <div className="card">
                  <div className="small">Interest drag (interest / rebates)</div>
                  <div className="value">{pct(k.interestAsPctOfRebates)}</div>
                  <div className="small">Informational</div>
                </div>

                <div className="card">
                  <div className="small">Debt cleared month</div>
                  <div className="value">{k.debtClearedMonth || "—"}</div>
                  <div className="small">First month EOM debt returns to £0</div>
                </div>
              </div>
            </div>
          );
        }

        return (
          <div className="page">
            <div className="row">
              <div>
                <h1>Deal Cashflow Model (single HTML file + scenarios + charts + sliders)</h1>
                <div className="small">
                  Sale Month is per-car (Mar–Sep 2026). Late Months is per-car (0–3) and applies to customer D2/D3/D4.
                  Scenario B adds an extra lateness overlay to D2/D3/D4. Events occur on the 15th (month-level precision).
                  Interest accrues daily ACT/365F and is paid at month-end; excess cash sweeps to repay debt.
                </div>
              </div>

              <div className="controls">
                <label className="small">
                  # Cars
                  <input
                    type="number"
                    min="1"
                    value={deal.numCars}
                    onChange={(e) => applyDealPatch({ numCars: Math.max(1, Number(e.target.value || 1)) })}
                    style={{ width: 100 }}
                  />
                </label>

                <label className="small">
                  Build months
                  <input
                    type="number"
                    min="1"
                    value={deal.buildMonths}
                    onChange={(e) => applyDealPatch({ buildMonths: Math.max(1, Number(e.target.value || 1)) })}
                    style={{ width: 120 }}
                  />
                </label>

                <label className="small">
                  Debt rate (annual)
                  <input
                    type="number"
                    step="0.001"
                    value={deal.annualRate}
                    onChange={(e) => applyDealPatch({ annualRate: Math.max(0, Number(e.target.value || 0)) })}
                    style={{ width: 140 }}
                  />
                </label>

                <label className="small">
                  Start month
                  <MonthInput value={deal.startMonth} onChange={(v) => applyDealPatch({ startMonth: v })} min="2026-01" />
                </label>

                <label className="small">
                  Scenario B extra lateness (months)
                  <input
                    type="range"
                    min="0"
                    max="3"
                    step="1"
                    value={scenarioBLateAdd}
                    onChange={(e) => setScenarioBLateAdd(Number(e.target.value))}
                  />
                  <span className="small mono">+{scenarioBLateAdd}m</span>
                </label>
              </div>
            </div>

            {/* Scenario KPI panels */}
            <div className="kpiGrid">
              {renderKpis("Scenario A (as-input lateness)", scenarioA.kpis)}
              {renderKpis(`Scenario B (Scenario A + ${scenarioBLateAdd}m lateness on D2/D3/D4)`, scenarioB.kpis)}
            </div>

            {/* Charts */}
            <div className="chartGrid">
              <div className="chartCard">
                <div className="chartHeader">
                  <div>
                    <div className="chartTitle">Chart 1: Exposure + Debt (Scenario A vs B overlays)</div>
                    <div className="small">All series on LHS; labels specify scenario.</div>
                  </div>
                </div>
                <div className="chartCanvasWrap">
                  <ChartCanvas config={chart1Config} ariaLabel="Exposure and debt over time for scenarios A and B" />
                </div>
                <div className="hint">
                  Net Exposure (Unfinanced) = cumulative manufacturer deposits − (cumulative customer receipts + cumulative rebates).
                </div>
              </div>

              <div className="chartCard">
                <div className="chartHeader">
                  <div>
                    <div className="chartTitle">Chart 2: Monthly Cashflow (stacked) + Debt (RHS) + Cumulative Profit (RHS2)</div>
                    <div className="small">Bright green line is cumulative profit (rebates). Debt is on RHS.</div>
                  </div>
                  <div className="chartTools">
                    <label className="small">
                      Chart scenario
                      <select value={chart2Scenario} onChange={(e) => setChart2Scenario(e.target.value)}>
                        <option value="A">Scenario A</option>
                        <option value="B">Scenario B</option>
                      </select>
                    </label>
                  </div>
                </div>
                <div className="chartCanvasWrap">
                  <ChartCanvas config={chart2Config} ariaLabel="Monthly cashflows with debt and cumulative profit overlay" />
                </div>
                <div className="hint">
                  Bars (LHS) show monthly inflows/outflows; debt (RHS) and cumulative rebates (RHS2) are lines.
                </div>
              </div>
            </div>

            {/* Feb–Dec 2026 summary (months as columns; split D1/D2; restore coloring) */}
            <div className="section">
              <div className="row">
                <div className="sectionTitle">Feb–Dec 2026 Summary (Monthly Cashflow + Exposure Roll-Forward)</div>
                <div className="badgeRow">
                  <span className="badge">Columns = months</span>
                  <span className="badge">Deposits collected split into D1 & D2</span>
                  <span className="badge">Green = collections/rebates, Red = manufacturer deposits</span>
                  <span className="badge">Customer D2 due month (all cars): {dueD2}</span>
                </div>
              </div>

              <div className="summaryGrid">
                {renderPivotTable("Scenario A", pivotA)}
                {renderPivotTable(`Scenario B (+${scenarioBLateAdd}m)`, pivotB)}
              </div>
            </div>

            {/* Per-car schedule (inputs) */}
            <div className="section">
              <div className="row">
                <div className="sectionTitle">Per-car inputs</div>
                <div className="badgeRow">
                  <span className="badge">Sale Month slider: Mar–Sep 2026</span>
                  <span className="badge">Late Months slider: 0–3 (applies to D2/D3/D4)</span>
                  <span className="badge">Scenario B adds +{scenarioBLateAdd}m on top</span>
                </div>
              </div>

              <div className="tableWrap">
                <table>
                  <thead>
                    <tr>
                      <th>Car</th>
                      <th>Sale Month (slider)</th>
                      <th>Late Months (slider)</th>
                      <th>Prod Start Month</th>
                      <th>Delivery Month</th>
                      <th>Due Months (D2 / D3 / D4)</th>
                      <th>Paid Months (Scenario A) (D2 / D3 / D4)</th>
                      <th>Paid Months (Scenario B) (D2 / D3 / D4)</th>
                    </tr>
                  </thead>
                  <tbody>
                    {cars.map((c) => {
                      const { dueD2, dueD3, dueD4, deliveryMonth } = computeDueMonths(deal, c.prodStartMonth);

                      const paidA_D2 = paidFromDueAndLate(dueD2, c.lateMonths);
                      const paidA_D3 = paidFromDueAndLate(dueD3, c.lateMonths);
                      const paidA_D4 = paidFromDueAndLate(dueD4, c.lateMonths);

                      const lateB = Math.max(0, Math.min(12, Number(c.lateMonths) + Number(scenarioBLateAdd)));
                      const paidB_D2 = paidFromDueAndLate(dueD2, lateB);
                      const paidB_D3 = paidFromDueAndLate(dueD3, lateB);
                      const paidB_D4 = paidFromDueAndLate(dueD4, lateB);

                      return (
                        <tr key={c.id}>
                          <td className="mono">{c.id}</td>

                          <td>
                            <div className="sliderWrap">
                              <div className="sliderRow">
                                <input
                                  type="range"
                                  min="0"
                                  max={String(SALE_MONTHS.length - 1)}
                                  step="1"
                                  value={saleIndexFromMonth(c.saleMonth)}
                                  onChange={(e) => updateCar(c.id, { saleMonth: saleMonthFromIndex(e.target.value) })}
                                />
                                <span className="pill"><span className="sliderValue">{c.saleMonth}</span></span>
                              </div>
                              <div className="mini">Customer D1 (£1m) received on <b>{c.saleMonth}-15</b>.</div>
                            </div>
                          </td>

                          <td>
                            <div className="sliderWrap">
                              <div className="sliderRow">
                                <input
                                  type="range"
                                  min="0"
                                  max="3"
                                  step="1"
                                  value={c.lateMonths}
                                  onChange={(e) => updateCar(c.id, { lateMonths: Number(e.target.value) })}
                                />
                                <span className="pill"><span className="sliderValue">{c.lateMonths}</span> mo</span>
                              </div>
                              <div className="mini">Applies to customer D2/D3/D4 in Scenario A; Scenario B adds +{scenarioBLateAdd}m.</div>
                            </div>
                          </td>

                          <td>
                            <MonthInput value={c.prodStartMonth} onChange={(v) => updateCar(c.id, { prodStartMonth: v })} />
                            <div className="mini">D3 due at start; P3 rebate +14 days.</div>
                          </td>

                          <td>
                            <div style={{ fontWeight: 700 }}>{deliveryMonth}</div>
                            <div className="mini">Delivery = start + {deal.buildMonths}m; P4 rebate +14 days.</div>
                          </td>

                          <td className="mono">
                            <div>D2 due: {dueD2}</div>
                            <div>D3 due: {dueD3}</div>
                            <div>D4 due: {dueD4}</div>
                          </td>

                          <td className="mono">
                            <div>{paidA_D2} / {paidA_D3} / {paidA_D4}</div>
                          </td>

                          <td className="mono">
                            <div>{paidB_D2} / {paidB_D3} / {paidB_D4}</div>
                          </td>
                        </tr>
                      );
                    })}
                  </tbody>
                </table>
              </div>
            </div>

            {/* Monthly outputs (end-of-month) - Scenario A only for audit */}
            <div className="section">
              <div className="sectionTitle">Monthly outputs (end-of-month) — Scenario A (audit)</div>
              <div className="tableWrap">
                <table>
                  <thead>
                    <tr>
                      <th>Month</th>
                      <th className="right">Cash (EOM)</th>
                      <th className="right">Debt (EOM)</th>
                      <th className="right">Net exposure (unfinanced)</th>
                      <th className="right">Cum customer receipts</th>
                      <th className="right">Cum mfg deposits</th>
                      <th className="right">Cum rebates</th>
                      <th className="right">Cum interest paid</th>
                    </tr>
                  </thead>
                  <tbody>
                    {scenarioA.monthly.map((r) => (
                      <tr key={r.month}>
                        <td className="mono">{r.month}</td>
                        <td className="right">{gbp(r.cashEOM)}</td>
                        <td className="right">{gbp(r.debtEOM)}</td>
                        <td className="right">{gbp(r.netExposureUnfinanced)}</td>
                        <td className="right">{gbp(r.cumCustomerIn)}</td>
                        <td className="right">{gbp(r.cumMfgOut)}</td>
                        <td className="right">{gbp(r.cumRebatesIn)}</td>
                        <td className="right">{gbp(r.cumInterestPaid)}</td>
                      </tr>
                    ))}
                  </tbody>
                </table>
              </div>
              <div className="small" style={{ marginTop: 8 }}>
                Net exposure (unfinanced) = cumulative manufacturer deposits − (cumulative customer receipts + cumulative rebates).
              </div>
            </div>

            {/* Audit ledger (Scenario A) */}
            <div className="section">
              <details>
                <summary className="sectionTitle">Audit ledger (chronological) — Scenario A</summary>
                <div className="tableWrap" style={{ marginTop: 10 }}>
                  <table>
                    <thead>
                      <tr>
                        <th>Date</th>
                        <th>Type</th>
                        <th>Label</th>
                        <th className="right">Amount</th>
                        <th className="right">Cash after</th>
                        <th className="right">Debt after</th>
                      </tr>
                    </thead>
                    <tbody>
                      {scenarioA.ledger.map((r, idx) => (
                        <tr key={idx}>
                          <td className="mono">{r.dateISO}</td>
                          <td className="mono">{r.type}</td>
                          <td>{r.label}</td>
                          <td className="right">{gbp(r.amount)}</td>
                          <td className="right">{gbp(r.cashAfter)}</td>
                          <td className="right">{gbp(r.debtAfter)}</td>
                        </tr>
                      ))}
                    </tbody>
                  </table>
                </div>
              </details>
            </div>

            <div className="section small">
              Hosting note: commit this as <span className="mono">index.html</span> in a GitHub repo and enable GitHub Pages. It will run as-is (no build step).
            </div>
          </div>
        );
      }

      const root = ReactDOM.createRoot(document.getElementById("root"));
      root.render(<App />);
    </script>
  </body>
</html>
